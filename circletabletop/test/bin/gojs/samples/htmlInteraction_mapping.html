<!DOCTYPE html>
<html>
<head>
<title>HTML Interaction</title>
<meta name="description" content="Show a GoJS Palette in a floating window and use an Inspector for changing the appearance of the selected node." />
<!-- Copyright 1998-2016 by Northwoods Software Corporation. -->
<meta charset="UTF-8">
<script src="go.js"></script>

<link rel="stylesheet" href="http://ajax.googleapis.com/ajax/libs/jqueryui/1.11.3/themes/smoothness/jquery-ui.css" />
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.11.3/jquery-ui.min.js"></script>

<!-- Spectrum color picker, pre-requisitie for the inspector -->
<link href="assets/spectrum.css" rel="stylesheet" type="text/css"/>
<script src="assets/spectrum.js"></script>

<link rel='stylesheet' href='../extensions/inspector.css' />
<script src="../extensions/inspector.js"></script>
<script src="../extensions/ExtendedBrush.js"></script>
<script src="../../dat.gui.js"></script>
<script src="../../guiGlue.js"></script>
<script src="../../index.js"></script>

<script id="code">
(function() {

	var myDiagramDivs;
	
	function onUIDragStart() {
		myDiagramDivs.css("pointer-events", "none");
	}
	function onUIDragStop() {
		myDiagramDivs.css("pointer-events", "auto");
	}
	
	

	function exposeHxMappingClassesToGlobalNamespace() {
		var p;
		var arr = [];
		for (p in textifician.mapping) {
			window[p] = textifician.mapping[p];
		}
	}
	exposeHxMappingClassesToGlobalNamespace();
	var TJSON = tjson.TJSON;
	
	var DatUtil = dat.gui.DatUtil;
	var world = new TextificianWorld();
	world.setupDefaultNew();
	
	
	
	window.init = init;
  function init() {
  
	//DATGUI
	var specsLocationDefinition = DatUtil.setup( new LocationDefinition() );
	var params = {};
	var gui = guiGlueRender(specsLocationDefinition, null, params);
	gui.domElement.addEventListener('dragstart', onUIDragStart);
	gui.domElement.addEventListener('dragstop', onUIDragStop);
  
	// GOJS
    if (window.goSamples) goSamples();  // init for these samples -- you don't need to call this

    // Note that we do not use $ here as an alias for go.GraphObject.make because we are using $ for jQuery
    var GO = go.GraphObject.make;  // for conciseness in defining templates

    myDiagram =
      GO(go.Diagram, "myDiagramDiv",  // must name or refer to the DIV HTML element
         { allowDrop: true,
			
		 	"undoManager.isEnabled": true,
                    "toolManager.hoverDelay": 100  // how quickly tooltips are shown
		 
		 }
		 
		);  // must be true to accept drops from the Palette
	myDiagram.mouseDrop = function(e, node) {

		  var it = myDiagram.toolManager.draggingTool.copiedParts;
		  if (it == null) {
			return;
		  }
		  it = it.iterator;
		  while (it.next()) {
				if (it.key instanceof go.Node) { 
					scaleNode(it.key, myDiagram.scale);
				}
				else if (it.key instanceof go.Link) {
					scaleLink(it.key, myDiagram.scale);
				}
		  }
		  

	}
	
	//myDiagram.linkTemplate.curve = go.Link.Bezier;
	myDiagram.linkTemplate.curviness = 1;
	//myDiagram.linkTemplate.bind(new go.Binding("curviness", "curviness"));

    // define several shared Brushes
    var fill1 = "rgb(105,210,231)"
    var brush1 = "rgb(65,180,181)";

    var fill2 = "rgb(167,219,216)"
    var brush2 = "rgb(127,179,176)";

    var fill3 = "rgb(224,228,204)"
    var brush3 = "rgb(184,188,164)";

    var fill4 = "rgb(243,134,48)"
    var brush4 = "rgb(203,84,08)";
	
	var TEXTLABEL_BASEWIDTH = 80;
	
	
	function getNodeTemplate(figure, fill, stroke, maxSize, layout) {
	
		var panelLayout = layout ? layout :  go.Panel.Vertical;
	 
		var textBlockParams = [go.TextBlock,
			{ 
			maxSize: new go.Size(TEXTLABEL_BASEWIDTH, NaN),
			wrap: go.TextBlock.WrapFit,
			textAlign: "center",
			editable: false,
			pickable: false,
			portId:"",
			font: "bold 7pt Arial, sans-serif",
			name: "TEXT" , portId:""
			},
			new go.Binding("text", "text" ).makeTwoWay()
		
		];
		
		textBlockParams.push(
				   new go.Binding("pickable", "", function(data) {
						return myDiagram.zoom < 1;
				  })
		  );
			
		///*
		//if (panelLayout === go.Panel.Spot) {
			textBlockParams.push(
				   new go.Binding("fromLinkable", "", function(data) {
						return myDiagram.model.modelData.linkable;
				  }),
					new go.Binding("toLinkable", "", function(data) {
						return myDiagram.model.modelData.linkable;
				  })
		  );
		//}
		//*/
		var textBlock  =  GO.apply(null, textBlockParams);


				
		var shape = GO(go.Shape, "Ellipse",
			  { strokeWidth: 2, fill: fill1, name: "SHAPE"
			 , desiredSize: new go.Size(16, 16)
				,maxSize:  new go.Size(maxSize ? maxSize : NaN, maxSize  ? maxSize : NaN)
				,figure:figure
				,fill:fill
				,stroke:stroke
				,portId: "", cursor: "pointer",  // the Shape is the port, not the whole Node
				// allow all kinds of links from and to this port
			  fromLinkableSelfNode: false, fromLinkableDuplicates: false,
			   toLinkableSelfNode: false, toLinkableDuplicates: false
			   
			  },
			  
			 // new go.Binding("figure", "figure"),
			  
			 //new go.Binding("fill", "fill"),
			 // new go.Binding("stroke", "stroke"),
			   
			 new go.Binding("desiredSize", "size")
			  
			  ,
				   new go.Binding("fromLinkable", "", function(data) {
						return myDiagram.model.modelData.linkable;
				  }),
					new go.Binding("toLinkable", "", function(data) {
						return myDiagram.model.modelData.linkable;
				  })
			  
			  );
			 
		var goParams = [go.Node, panelLayout,
        { locationSpot: go.Spot.Center },
        new go.Binding("location", "loc").makeTwoWay()];
			
		if (panelLayout == go.Panel.Spot)  goParams.push(shape, textBlock);
		else goParams.push(textBlock, shape);
		return GO.apply(null, goParams);
	}



	 myDiagram.nodeTemplateMap.add("point", getNodeTemplate("Square",fill1,brush1, 5));
	  myDiagram.nodeTemplateMap.add("path", getNodeTemplate("Diamond",fill2,brush2));
	  myDiagram.nodeTemplateMap.add("region",getNodeTemplate("Circle",fill3,brush3, null, go.Panel.Spot));

	  function scaleLink(link, newscale) {
		link.curviness = 1 * origscale/newscale;
	  }
	  function scaleNode(node, newscale) {
	  	//origscale / newscale;
			
			var text = node.findObject("TEXT");
			text.scale =  origscale / newscale;//newscale < .5 ? origscale / newscale*.5 : 1;
			text.visible = newscale >= .1 ? true : false; 
			text.maxSize.width = TEXTLABEL_BASEWIDTH * origscale / newscale;
			if (node.category === "point") {
				var shape = node.findObject("SHAPE");
				shape.scale =  newscale >= .2 ? 1 :  origscale / newscale * .2;
			}
	  }
	  
	  // This code keeps all nodes at a constant size in the viewport,
      // by adjusting for any scaling done by zooming in or out.
      // This code ignores simple Parts;
      // Links will automatically be rerouted as Nodes change size.
      var origscale = NaN;
      var oldscale = NaN;
      myDiagram.addDiagramListener("InitialLayoutCompleted", function(e) { origscale = oldscale = myDiagram.scale; });
      myDiagram.addDiagramListener("ViewportBoundsChanged", function(e) {
        if (isNaN(origscale)) return;
        var newscale = myDiagram.scale;
        if (oldscale === newscale) return;  // optimization: don't scale Nodes when just scrolling/panning
        oldscale = newscale; 
        myDiagram.skipsUndoManager = true;
        myDiagram.startTransaction("scale Nodes");
		
		//myDiagram.linkTemplate = myDiagram.linkTemplate;
		
        myDiagram.nodes.each(function(node) {  // consider todo: only perform for nodes within visibility set? need to form visibilty set per scroll though.
		
			scaleNode(node, newscale);
			
          });
		  
		   myDiagram.links.each(function(link) {  // consider todo: only perform for nodes within visibility set? need to form visibilty set per scroll though.
		
			scaleLink(link, newscale);
			
          });
		  
		  
		 // myDiagram.model.updateTargetBindings("
        myDiagram.commitTransaction("scale Nodes");
        myDiagram.skipsUndoManager = false;
		
      });
	  
	  
	
	function writePropertiesOver(obj, src) {
		var p;
		if (src == null) return obj;
		for(p in src) {
		
			obj[p] = src[p];
		}
		return obj;
	}
		  
	var textProxy = {
	   get : function() {
			return this.node.val.defOverwrites != null && this.node.val.defOverwrites.label  ? this.node.val.defOverwrites.label : this.node.val.def.label;
	   },
	   set : function(val) {
			var prefix = val.charAt(0);
			if (prefix=== "#") {	// lookup location definition
				val = val.slice(1);
				var tryDef = world.getLocationDef( val );
				if (tryDef != null) {
					this.node.val.def = tryDef;
					this.node.val.defOverwrites = null;
					this.isProto =  val =="Point" || val ==="Path" || val === "Region";
				}
				else {
					alert("Failed to find location definition: "+val);
				}
			}
			else if (prefix === "~") {  // write label directly into location definition
				if (this.isProto || val =="Point" || val ==="Path" || val === "Region") {
					alert("Sorry, cannot write label directly into prototype location definition id! Save it first with * prefix!");
					return;
				}
				val = val.slice(1);
				if (this.node.val.defOverwrites != null) {
					delete this.node.val.defOverwrites["label"];
				}
				this.node.val.def.label = val;
			}
			else if (prefix === "*") { // save location definition
				val = val.slice(1);
				//
				var dupLoc;
				
				if (val.charAt(0) === "#") {
					val = val.slice(1);
					if (val === "") {
						if (this.isProto || this.node.val.def.id =="Point" || this.node.val.def.id ==="Path" || this.node.val.def.id === "Region") {
							alert("Sorry, cannot write directly into prototype location definition! Save it first with * prefix!");
							return;
						}
						else writePropertiesOver(this.node.val.def , this.node.val.defOverwrites);
						this.node.val.defOverwrites = null;
						return;
					}
					dupLoc = writePropertiesOver( world.getDuplicationLocationDef(this.node.val.def, val) , this.node.val.defOverwrites);
				}
				else {
					if (val === "") {
						if (this.isProto || this.node.val.def.id =="Point" || this.node.val.def.id ==="Path" || this.node.val.def.id === "Region") {
							alert("Sorry, cannot write directly into prototype location definition! Save it first with * prefix!");
							return;
						}
						else writePropertiesOver(this.node.val.def , this.node.val.defOverwrites);
						this.node.val.defOverwrites = null;
						return;
					}
					if (this.node.val.defOverwrites == null) this.node.val.defOverwrites = {};
					this.node.val.defOverwrites.label = val;
					dupLoc = writePropertiesOver( world.getDuplicationLocationDef(this.node.val.def, val) , this.node.val.defOverwrites);
				}
			
				try {
					world.addLocationDef(dupLoc);
					this.node.val.defOverwrites = null;
					this.node.val.def = dupLoc;
					this.isProto = false;
				}
				catch(err) {
					alert(err);
				}
				
			}
			else {  // write label overwrite
				if (val =="Point" || val ==="Path" || val === "Region") {
					alert("Sorry, prototype id value reserved");
					return;
				}
				if (val === "") {
					if (this.node.val.defOverwrites != null) {
						delete this.node.val.defOverwrites["label"];
						
						
					}
					val = this.node.val.def.label;
					this.isProto =  val =="Point" || val ==="Path" || val === "Region";
					return;
				}
				if (this.node.val.defOverwrites == null) {
					this.node.val.defOverwrites = { label: val };
				}
				else this.node.val.defOverwrites.label = val;
				//this.node.val.def.label = val;
			
			}
	   }
	};
	
	
					
	function updateRelatedNodesOfModel(model, def, prop) {
		var nodeDataArr = model.nodeDataArray;
		var i = nodeDataArr.length;
		var o;
		while(--i > -1) {
			o = nodeDataArr[i];
			if (o.node && o.node.val.def === def) model.updateTargetBindings(nodeDataArr[i], prop);
		}
	}
	
	
	
	
  myDiagram.model.linkKeyProperty = "key";
  myDiagram.model.addChangedListener(function(e) {
    if (e.isTransactionFinished) {
      var tx = e.object;
	  
      if (tx instanceof go.Transaction && console && e.model) {
        console.log(tx.toString());
		
		if (true || tx.name != "Move") {
		
			var methodToCalls = [];
			var nodesToAdd = [];
			tx.changes.each(function(c) {
			
			  if (c.model) {
				if ( c.model === c.object ) { // deemed insertion or removal
					if (c.newValue != null && c.oldValue == null) {  // insertion infered
					
						if (c.propertyName == "nodeDataArray") {  // insert node
							nodesToAdd.push( c.newValue );
						}
						else if (c.propertyName == "linkDataArray") {  // create link
							
						}
					}
					else if (c.newValue == null && c.oldValue != null) { // removal infered
						if (c.propertyName == "nodeDataArray") {  // remove node
							//alert("REMOVE NODE");
							
						}
						else if (c.propertyName == "linkDataArray") {  // remove link
							//alert("REMOVE LINK");
						}
					}
					else {
						console.log	("Could not resolve this transaction case: "+tx);
					}
				}
				else {  // deemed modifying of data within model
					if (c.propertyName === "loc") {   // moving 
						var n = c.object.node;
						if (n != null) {
							n.val.x = c.newValue.x;
							n.val.y = c.newValue.y;
						}
					}
					else if (c.propertyName === "linkable") {
						// irreleavant. do nothing
					}
					else if (c.propertyName === "text") {
						methodToCalls.push(updateRelatedNodesOfModel, [e.model, c.object.node.val.def, "text"]);
						methodToCalls.push(updateRelatedNodesOfModel, [myPalette.model, c.object.node.val.def, "text"]);
					}
					else if (c.propertyName === "size") {
						// todo: reflect c
					}
					else if (c.propertyName === "node") {
						// irrelavant
					}
					else { //
					  alert("could not resolve:"+c.propertyName);
					}
				}
				
			
				
				console.log( c.object," " +c.modelChange + ","+c.propertyName+","+c.oldParam +", "+c.newParam );
				//console.log("OldValue:", c.oldValue);
				//console.log("NewValue:", c.newValue);
				
				//console.log( model.toIncrementalJson(e) );
			  }
			});
			
			var i;
			for(i=0; i< methodToCalls.length; i+=2) {
				methodToCalls[i].apply(null, methodToCalls[i+1]);
			
			}
			
			// creation of nodes
				i = 0;
					var v;
				var o;
				for (i=0; i<nodesToAdd.length; i++) {
					o =nodesToAdd[i];
					if (o.node != null) {  // DUPLICATE NODE CASE
						//alert(flagDownKeys );
						e.model.setDataProperty(o,"node",v= world.addLocationNode(world.getLocationDef(o.node.val.def.id), o.loc.x, o.loc.y, 0, null, ( false ? o.node.val.cloneOverwrites() : o.node.val.defOverwrites) ));
					}
					else {  // NEW NODE CASE
						
						e.model.setDataProperty(o,"node",v= world.addLocationNode(world.getLocationDef(o.locid).setSize(o.size.width), o.loc.x, o.loc.y, 0, null, null ));
					}
					
					if (o.text != textProxy) {
						Object.defineProperty(o,"text",textProxy);
						e.model.updateTargetBindings(o, "text");
					}
			

				}
	
		  }
		//  /*
		  else  {   // DEPRECIATED atm due to recursion problem with toIncrementalJSON
			//	/*
				console.log( e.model.toIncrementalJson(e) );
				var moveJson = e.model.toIncrementalJson(e);
				moveJson = JSON.parse(moveJson);
				var modData = moveJson.modifiedNodeData;
				
				var i =modData ?  modData.length : 0;
				var o;
				while(--i > -1) { // readonly
					o = modData[i];
					//= o.loc.x;
					//= o.loc.y;
					
				}
				//*/
	
				
				
		  }
		//  */
	  }
	  
    }
  });
		  
	function classify(instance) {
		instance["class"] = "awawaawtwaaw";
		return instance;
	}


    // initialize the Palette that is in a floating, draggable HTML container
    myPalette = new go.Palette("myPaletteDiv");  // must name or refer to the DIV HTML element
	myPalette.allowZoom = false;
	
//	palTemplate.findObject("SHAPE").maxSize = new go.Size(20,20);
	myPalette.nodeTemplateMap.add("point", getNodeTemplate("Square",fill1,brush1,20));
	 myPalette.nodeTemplateMap.add("path", getNodeTemplate("Diamond",fill2,brush2,20));
	 myPalette.nodeTemplateMap.add("region",getNodeTemplate("Circle",fill3,brush3,20));
	  
  	
	  
    myPalette.model = new go.GraphLinksModel([
      { locid:"Point", isProto:true, text:"Point", category:"point",  size:new go.Size(5,5)   },
      { locid:"Path", isProto:true, text:"Path",  category:"path",  size:new go.Size(12,12) },
      { locid:"Region", isProto:true,  text:"Region",  category:"region", size:new go.Size(30,30) }
    ]);
	
	var FLAG_SHIFT_DOWN = 1;
	var flagDownKeys = 0;
	
	jQuery(window).keydown( function(e) {
		if (e.keyCode === 16) {	 // shift
			flagDownKeys |= FLAG_SHIFT_DOWN;
			myDiagram.model.setDataProperty(myDiagram.model.modelData, "linkable", true);
			
		}
		//console.log(flagDownKeys);
	});
	jQuery(window).keyup( function(e) {
		if (e.keyCode === 16) {  // shift
			flagDownKeys &= ~FLAG_SHIFT_DOWN;
			myDiagram.model.setDataProperty(myDiagram.model.modelData, "linkable", false);
		}
	//	console.log(flagDownKeys);
		
		 
	});

    myPalette.addDiagramListener("InitialLayoutCompleted", function(diagramEvent) {
      var pdrag = document.getElementById("paletteDraggable");
      var palette = diagramEvent.diagram;
      var paddingHorizontal = palette.padding.left + palette.padding.right;
      var paddingVertical = palette.padding.top + palette.padding.bottom;
	  pdrag.style.top = 8  + "px";
	  pdrag.style.left = 270  + "px";
      pdrag.style.width = palette.documentBounds.width + 20  + "px";
      pdrag.style.height = palette.documentBounds.height + 30 + "px";
    });
	
	$("#infoDraggable").focus( function() {
		
	});
	
	myDiagramDivs = $("#myDiagramDiv").add($("#myPaletteDiv"));
	
	
	
	


    $(function() {
        $("#paletteDraggable").draggable({handle: "#paletteDraggableHandle", start:onUIDragStart, stop:onUIDragStop}).resizable({
          // After resizing, perform another layout to fit everything in the palette's viewport
		  start: onUIDragStart,
          stop: function(){ myPalette.layoutDiagram(true); onUIDragStop(); }
        });

        var inspector = new Inspector('infoDraggable', myDiagram,
          {
            
		  acceptButton: true,
            resetButton: true
          // /*
			, propertyNames: {
		//		"Node": ["category"],
              //"Node": ["location", "background", "scale", "angle", "isShadowed", "resizable"],
              //"#SHAPE": ["fill", "stroke", "strokeWidth", "figure"],
              "#TEXT": ["text"]
            }
			//*/
          });
		  
        });

  }
  
})();
</script>



<style type="text/css">
.draggable {
  display: inline-block;
  vertical-align: top;
  border: 4px solid #BBB;
  border-radius: 4px;
  background-color: #F5F5F5;

  position: absolute;
  top: 20px;
  left: 120px;
  z-index: 500;
}

.dg textarea {
	font-size:12px;
}
.dg input[type=text] {
	font-size:12px;
}
li.folder.bitmask ul {
	background-color:black;
}
li.folder.bitmask ul li.boolean {
	display:inline-block;
}
li.folder.bitmask ul li .property-name {
	width:auto;
}
li.folder.bitmask ul li.boolean .c {
	width:auto;
}

li.folder.instance .title {
	background-image:none;
	padding-left:8px;
}

li.folder.instance .title:before {
	margin-right:8px;
	content:'\2611';
}

li.folder.instance .closed .title:before {
	content:'\2610';
}


.handle {
  background-color: lightblue;
  cursor: move;
  text-align: center;
  font: bold 12px sans-serif;
}

#infoDraggable {
  font: 12px helvetica, sans-serif;
  background-color:rgba(45,45,45,.8);
}	

#infoDraggable .inspector {
	background-color:#000000;
	
	display:block;
}

#myInfo {
  padding: 6px;
}

#myPaletteDiv {
  background-color: #F5F5F5;
  width: 100%;
  height: 100%;
}

/*
One simple way of making a div fill its space,
with allowances for the title (top) and the resize handle (bottom)
*/
#paletteContainer {
  position:absolute;
  bottom: 14px;
  left: 0px;
  right: 0px;
  top: 14px;
}

#infoDraggableInstruct  {
	
}
#infoDraggableInstruct span {
	font-style:normal;	
	font-weight:bold;
	color:yellow;
}
#infoDraggableInstruct i {
	font-size:11px;
	font-weight:normal;
}
 canvas:focus{outline:none;}
</style>
</head>
<body onload="init()" style="margin:0;padding:0">
<div id="sample">

    <div id="paletteDraggable" class="draggable" style="height: 300px;	">
      <div id="paletteDraggableHandle" class="handle">Palette</div>
      <div id="paletteContainer">
        <div id="myPaletteDiv"></div>
      </div>
    </div>

    <div style="display: block; z-index:0;vertical-align: top;  padding:0;margin:0;width:100%; height:100%;position:absolute; top;0; left:0;">
      <div id="myDiagramDiv" style="outline:none;background-color:whitesmoke; border: solid 1px #dddddd; margin:0 auto;	  width:90%; height: 90%"></div>
    </div>

    <div id="infoDraggable" style="position:relative; display: inline-block; vertical-align: top; padding: 5px; z-index:1">
      <div id="myInfo" style="visibility:visible; margin-bottom:20px;"><h3>Textifician Mapper</h3>Selecting nodes in the Main Canvas will display information here</div>
	  <div id="infoDraggableInstruct" style="position:absolute;bottom:0;left:0;padding:5px;">
		 <h4>TEXT <span>prefix</span> legend:</h4>
		 <p>
		<span>(no prefix)</span> <i>Create overwrite label</i> <hr/>
		<span>~</span>  <i>Write label into existing definition</i><hr/>
		<span>#</span>   <i>Load definition</i><hr/>
		<span>*</span> <i>Save into New definition (auto-generate id)</i><hr/>
		<span>*#</span> <i>Save into New definition (with id) </i><hr/>
		<i>NOTE: When saving, if text is an empty string, will save all existing overwrites over current LocationDefinitionID.</i>
</p>
	  </div>
    </div>

  

</div>
</body>
</html>

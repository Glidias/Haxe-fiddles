<!DOCTYPE html>
<html>
<head>
<title>HTML Interaction</title>
<meta name="description" content="Show a GoJS Palette in a floating window and use an Inspector for changing the appearance of the selected node." />
<!-- Copyright 1998-2016 by Northwoods Software Corporation. -->
<meta charset="UTF-8">
<script src="go.js"></script>

<link rel="stylesheet" href="http://ajax.googleapis.com/ajax/libs/jqueryui/1.11.3/themes/smoothness/jquery-ui.css" />
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.11.3/jquery-ui.min.js"></script>

<!-- Spectrum color picker, pre-requisitie for the inspector -->
<link href="assets/spectrum.css" rel="stylesheet" type="text/css"/>
<script src="assets/spectrum.js"></script>

<link rel='stylesheet' href='../extensions/inspector.css' />
<script src="../extensions/inspector.js"></script>
<script src="../extensions/ExtendedBrush.js"></script>
<script src="../../dat.gui.js"></script>
<script src="../../guiGlue.js"></script>
<script src="../../vue.min.js"></script>
<script src="../../index.js"></script>

<script id="code">
(function() {

	var myDiagramDivs;
	
	function onUIDragStart() {
		myDiagramDivs.css("pointer-events", "none");
	}
	function onUIDragStop() {
		myDiagramDivs.css("pointer-events", "auto");
	}
	
	// TODO:
	
	// pin adornment
	// do not allow selection of prototypes, hide locationdefinition guis for prototypes
	
	// location definition overwrites
	// location definition list dropdown
	
	
	function getCategoryStringFromType(newValue) {
	
		if (typeof(newValue) != 'number') {
			alert("Wrong type assigned for:"+newValue + "::" +typeof(newValue) + ", "+(newValue===null));
			return;
		}
		return newValue === LocationDefinition.TYPE_POINT ? "point" : newValue=== LocationDefinition.TYPE_PATH ? "path" : "region";
	}
	function getUniformSize(size) {
		if (typeof(size) != 'number') return;
		if (size < 0) size = 999999999;
		return new go.Size(size,size);
	}
	
	function updateAllControllers(newTarget) {
		// method to update all object targets of:
	  var i =  this._controllers.length;
	  var c;
	 
	  while(--i > -1) {
		c = this._controllers[i];
		c.object = newTarget;
		c.updateDisplay();
	  }
	  
	   // and all sub-leaf proxies:
	   if (this["_subProxies"]) {
		 i = this._subProxies.length;
		  while(--i > -1) {
			this._subProxies[i]._target = newTarget;
			
		 }
	   }
	}
	
	var targetProxyHandler = {
		set: function(t, prop, value, receiver) {
			if (prop.charAt(0) != "_") {
				t._target[prop] = value;
			 
			}
			else  {
				t[prop]= value;
				if (prop === "_target" && t["_onTargetChanged"]) {
					t._onTargetChanged.apply(t, [value]);
				}
			}
		}
		,get: function(t, prop, receiver) {

			return (prop.charAt(0) != "_" ? t._target : t )[prop];
		}
	};
	


	function exposeHxMappingClassesToGlobalNamespace() {
		var p;
		var arr = [];
		for (p in textifician.mapping) {
			window[p] = textifician.mapping[p];
		}
	}
	exposeHxMappingClassesToGlobalNamespace();
	var TJSON = tjson.TJSON;

	
	var DatUtil = dat.gui.DatUtil;
	//DatUtil.DEFAULT_FLOAT_STEP = .001;
	
	var world = new TextificianWorld();
	world.setupDefaultNew();
	var worldProtoLocIds = world.getDefaultLocationDefIdHash();
	

	
	window.init = init;
	
	var allLocationGUIDom = $("");
	
	
	function guiFunction(obj, labelProp, func) {
		var labelToUse =obj[labelProp];
		obj[labelToUse] = func;
		return labelToUse;
	}

  function init() {
  
	//DATGUI
	var specsLocationDefinition = DatUtil.setup( new LocationDefinition() );
	specsLocationDefinition.size.step = .001;
	

	var gui = setupGUIGeneric( guiGlueRender(specsLocationDefinition, null, {}) );
	gui.domElement.setAttribute("id", "locationDefGUI");
	gui.getControllerByName("size").__input.setAttribute("step", "any");

	/*
	var guiCmdLabels = {
		"ADD_LOCATION_STATE": "Add location state..."
	}
	var guiCmd = setupGUIGeneric(new dat.GUI() ).add( guiCmdLabels,
		guiFunction(guiCmdLabels, "ADD_LOCATION_STATE", function() {
			alert("A");
		}) 
	);
	guiCmd.domElement.setAttribute("id", "guiCmd");
	*/
	
	
	
	var guiOverwriter = setupGUIGeneric( guiGlueRender(specsLocationDefinition, null, {}) );
	guiOverwriter.domElement.setAttribute("id", "locationDefGUIOverwriter");
	
	//var guiStater = setupGUIGeneric( guiGlueRender( DatUtil.setup( new LocationState() ), null, {}) );
	//guiStater.domElement.setAttribute("id", "locationStateGUI");
	
	var guiPacketer = new dat.GUI();
	guiPacketer.addFolder( "position");
	guiPacketer = setupGUIGeneric( guiGlueRender( DatUtil.setup(new LocationPacket()), null, {}, guiPacketer) );
	guiPacketer.domElement.setAttribute("id", "guiPacketer");
	$( guiPacketer.getFolderByName("state").domElement.firstChild ).children("li.title").html("Location state{{selected.state ? ':' : '?' }}");
	$( guiPacketer.getFolderByName("position").domElement.firstChild ).children("li.title").html("position: {{ (selected && selected.x!== undefined ? '('+selected.x + ',' + selected.y + ',' + selected.z+')' : '') }}");
	$( guiPacketer.getFolderByName("position").domElement.firstChild).append( $(guiPacketer.domElement).find("li.position") );
	
	
	var guiArc = setupGUIGeneric( guiGlueRender( DatUtil.setup( new ArcNodeVM() ) , null, {}  ) );
	guiArc.domElement.setAttribute("id", "arcGUI");
	$(guiArc.domElement).attr("v-show", "selectedArc!=null" ).find(".primaryArc > div > ul > li.title").html("Arc state{{selectedArc && selectedArc.val ? ':' : '?' }}");
	
	// some mods for filtering
	var liNumberRows = $(gui.domElement).add($(guiOverwriter.domElement)).find("li.number");	
	liNumberRows.find("input").each( function(index, item) {
		item = $(item);
		item.attr( "number", "");
	});

	liNumberRows.find("select").each( function(index, item) {
		item = $(item);
		item.attr( "number", "");
	});
	

	Vue.directive('dat-instance', {  // Binds to Dat.gui folders's domElement.firstChild => UL element
		bind: function(val) {
			var self = this;
			this._datGui = $(this.el).data("dat-gui");
			 this._datGui.onClosedChange( function(isClosed) {
				self.vm.$set( self.expression, (isClosed ? null : self._datGui._guiGlueParams ) );
			 });
		},
		update: function(val, lastVal) {
	
			this._datGui.closed = val == null;
		
			
		},
		unbind: function() {
			this._datGui.onClosedChanged(null);
		}
	});

	
	Vue.directive('dat-numeric-input',{  // Binds to Dat.gui controller's domElement.firstChild => Div input element
		bind: function() {
			var self = this;
			this._datController = $(this.el).data("dat-controller");
			 this._datController.onChange( function(val) {
				self.vm.$set( self.expression, val );
			 });
		},
		update: function(val) {
			if ( isNaN(val)) return;
			this._datController.setValue(val);//(val);
			this._datController.updateDisplay();
		},
		unbind: function() {
			 this._datController.onChange(null);
		}
	});


	Vue.directive('dat-slider',{  // Binds to Dat.gui controller's domElement.firstChild => Div wrapper element
		bind: function() {
			var self = this;
			this._datController = $(this.el).data("dat-controller");
				this._datController.onChange( function(val) {
				self.vm.$set( self.expression, val );
			 });
		},
		update: function(val) {
			if ( isNaN(val)) return;
			this._datController.setValue(val);
		},
		unbind: function() {
			 this._datController.onChange(null);
		}
	});
	
	Vue.directive('dat-bitmask',{  // Binds to Dat.gui folder's domElement.firstChild => UL element
		bind: function() {
			var self = this;
			//var liBoolList = $(this.el).children("li.boolean");
			var el = $(this.el);
			var folder = el.data("dat-gui");
			var controllers = folder.__controllers;
			var p;
			var c;
			var len = controllers.length;
			var initialValue = 0;
			
			var titleCheck = el.children("li.title");
			titleCheck.html( titleCheck.html() + ": ");
			var labelListCheck = titleCheck.children("span.labellist");
			if (labelListCheck.length ==0 ) {
				labelListCheck = $('<span class="labellist"></span>');
				titleCheck.append(labelListCheck);
			}
			
			
			this.labelList = labelListCheck;
			this.controllers = controllers;
			this._folder = folder;
			
			
			for (i=0; i< len; i++) {
				c = controllers[i];
				initialValue |= c.getValue() ? c._guiGlue._bit : 0;
				c.onChange(function(val) {
					if (val) {
						self.bitmaskValue |= this._guiGlue._bit;
					}
					else {
						self.bitmaskValue &= ~(this._guiGlue._bit);
					}
					
					if (self.vm.$get(self.expression) !== undefined) self.vm.$set( self.expression, self.bitmaskValue );
					
					//console.log( self.expression + "=" + self.bitmaskValue);
				});
			}
			
			this.bitmaskValue = initialValue;
		//	console.log( self.expression + "=" + this.bitmaskValue);
		
		},
		update: function(val, lastVal) {	
			//alert(val); 
			if (val === undefined) {
				val = this._folder._guiGlue._value;
				
			}
			else if (!val) {
				val = 0;
			}
			this.bitmaskValue = val;
			
			var i;
			var c;
			var controllers= this.controllers;
			var len = controllers.length;
			var arr = [];
			var v;
			for (i=0; i< len; i++) {
				c = controllers[i];
				c.setValue( v=(val & c._guiGlue._bit)!=0 );
				if (v) arr.push('<span class="prop">'+c.property+'</span>');
			}
			
			this.labelList.html( ""+arr.join(", ") );
		},
		unbind: function() {
			var i;
			var controllers= this.controllers;
			var len = controllers.length;
			for (i=0; i< len; i++) {
				controllers[i].onChange( null );
			}
		}
	});


	
	var p;
	var g;
	var c;
	var f;
	
	var guiSubInstances = [];
	
	function resetAllGUISubInstances() {   
		var i  = guiSubInstances.length;
		while(--i > -1) {
			guiGlueApplyDefaults(guiSubInstances[i]._guiGlue, guiSubInstances[i]._guiGlueParams);
		}
	}
	
	//$(guiOverwriter.domElement).data("dat-gui", guiOverwriter).attr("v-if", "selected.defOverwrites != undefined");
	
//	$(guiOverwriter.domElement)

	function setupGUIForVue(gui, expressionPrefix, ifSuffix, overwriteMethod, dataModelDirective) {
		var guiFolders = gui.getAllGUIs();
		var gotIf = ifSuffix != null;
		if (overwriteMethod == null) overwriteMethod = "addLocationDefOverwrite";
		if ( !dataModelDirective) dataModelDirective = "node";
		dataModelDirective = "v-"+dataModelDirective;

	
		for (p in guiFolders) {
			g= guiFolders[p];
			if (!g._guiGlue) continue;
			
			if (g._guiGlue._dotPath != undefined) {
				if (g._guiGlue._dotPath != "") {
					$(g.domElement.firstChild).data("dat-gui", g).attr("v-dat-instance", expressionPrefix+ g._guiGlue._dotPath).attr(dataModelDirective, expressionPrefix+ g._guiGlue._dotPath);
					
					var overwriteTrigger = jQuery(jQuery(g.domElement).parents("li")[0]).find(".overwritetrigger").data("dat-gui", g);
					overwriteTrigger.attr("v-on:click", overwriteMethod+"('"+g._guiGlue._dotPath+"', $event)");
					//selected && selected.defOverwrites && 
					if ( expressionPrefix === "selected.def.") overwriteTrigger.attr("v-show", "$get('selected.defOverwrites."+g._guiGlue._dotPath+ "') == null");
					
					if (gotIf) {
						$( $(g.domElement).parents("li")[0]).attr("v-show", expressionPrefix +g._guiGlue._dotPath +  ifSuffix);
					}
					guiSubInstances.push(g);
					
				}
				
			
					
				
				for (c in g.__controllers) {
					var cn = g.__controllers[c];
					
					var dotPath =( g._guiGlue._dotPath!= "" ?  g._guiGlue._dotPath + "." : "")+ cn.property;
					
					
					var nodeName = cn.domElement.firstChild.nodeName.toLowerCase();
					if (nodeName != "div") {  // assumed input
						jQuery(cn.domElement.firstChild).data("dat-controller", cn);
						//if (jQuery(cn.domElement.firstChild).parents("li.number").length) {
						//	cn.domElement.firstChild.setAttribute("lazy", "");
						//}
						if (jQuery(cn.domElement.firstChild).parents("li.number").length && nodeName === "input") {
							cn.domElement.firstChild.setAttribute("v-dat-numeric-input", expressionPrefix+dotPath);
						}
						else {
							cn.domElement.firstChild.setAttribute("v-model", expressionPrefix+dotPath);
						}
					}
					else {
						if (jQuery(cn.domElement.firstChild).parents("li.has-slider").length) {
							jQuery(cn.domElement.firstChild).data("dat-controller", cn).attr("v-dat-slider", expressionPrefix+dotPath);
						}
						else alert("TODO: NEED TO resolve controller directive for:"+cn.property);
						
					}
					
					var overwriteTrigger = jQuery(jQuery(cn.domElement).parents("li")[0]).find(".overwritetrigger").data("dat-gui", cn);
					if (overwriteTrigger.length) {
						if (!cn._guiGlue._readonly) {
							overwriteTrigger.attr("v-on:click", overwriteMethod+"('"+dotPath+"', $event)");
							//selected && selected.defOverwrites && 
							if ( expressionPrefix === "selected.def.") overwriteTrigger.attr("v-show", "$get('selected.defOverwrites."+dotPath+ "') == null");
						}
						else {
							overwriteTrigger.css("display", 'none').css("visibility", "hidden");
						}
					}
					
					cn.domElement.firstChild.setAttribute(dataModelDirective, expressionPrefix+dotPath);
					if (gotIf) $( $(cn.domElement).parents("li")[0]).attr("v-show", expressionPrefix + dotPath  +  ifSuffix);
				}
				
				for (f in g.__folders) {
					var folder = g.__folders[f];
					if (!folder._guiGlue) continue;
					if (folder._guiGlue._dotPath == undefined) {
						var parentLI = jQuery( jQuery(folder.domElement).parents("li")[0] );
						if (parentLI.hasClass("bitmask")) {
							var dotPath =( g._guiGlue._dotPath!= "" ?  g._guiGlue._dotPath + "." : "")+ f;
							$(folder.domElement.firstChild).data("dat-gui", folder).attr("v-dat-bitmask", expressionPrefix+dotPath ).attr(dataModelDirective, expressionPrefix+dotPath);
							var folderLi =  $( $(folder.domElement).parents("li")[0]);
							if (gotIf) folderLi.attr("v-show", expressionPrefix + dotPath  +  ifSuffix);
							var overwriteTrigger = folderLi.children(".overwritetrigger").data("dat-gui", f);
							
							overwriteTrigger.attr("v-on:click", overwriteMethod+"('"+dotPath+"', $event)");
							//selected && selected.defOverwrites && 
							if ( expressionPrefix === "selected.def.") overwriteTrigger.attr("v-show", "$get('selected.defOverwrites."+dotPath+ "') == null");
						}
						else {
							//alert("TODO: need to resolve folder directive for:"+f );<br/>
						}
					}
				}
			}
		}
	}
	
	$(gui.domElement).children("ul").children("li").children().children(".property-name").append('<span class="overwritetrigger">+</span>');
	$(gui.domElement).children("ul").children("li.instance, li.bitmask").append('<span class="overwritetrigger">+</span>');
	
	$(guiOverwriter.domElement).children("ul").children("li").children().children(".property-name").append('<span class="overwritetrigger">-</span>');
	$(guiOverwriter.domElement).children("ul").children("li.instance, li.bitmask").append('<span class="overwritetrigger">-</span>');
	
	setupGUIForVue(gui,  "selected.def.");
	
	setupGUIForVue(guiOverwriter,  "selected.defOverwrites.", "!==undefined", "removeLocationDefOverwrite");
	setupGUIForVue(guiPacketer,  "selected.");
	setupGUIForVue(guiArc, "selectedArc.", null,null, "arc");
	guiPacketer.domElement.setAttribute("v-show", "gotLocation");
	//setupGUIForVue(guiStater,  "selected.state.");
	gui.domElement.setAttribute("v-show", "selected.def");
	gui.domElement.setAttribute("v-bind:class", "{ 'disabled': isProto && gotLocation }");
	guiOverwriter.domElement.setAttribute("v-show", "gotLocation &&  selected.defOverwrites");
	guiOverwriter.domElement.setAttribute("v-node", "selected.defOverwrites");
	
	//guiStater.domElement.setAttribute("v-show", "selected.state");
	//guiStater.domElement.setAttribute("v-node", "selected.state");
	
	$(guiOverwriter.domElement).add($(guiPacketer.domElement)).css("float", "none").css("margin-bottom", "28px").wrapAll($('<div style="float:right"></div>'));
	

	// App specific setup
	
	var inspectPropertyChainLookup = TextificianUtil.getPropertyChainObj({}, "");
	var _inspectedNodeVal=null;
	var _inspectedArc = null;
	var _inspectedGoNodeData = null;
	var _selectedGoNodeData = null;
	var _selectedGoArcData = null;
	var leafBindingHash = { size:"desiredSize", label:"text", type:"category" };
	
	
	Vue.directive('arc', function(newValue, oldValue) {
	
		if (_inspectedArc == null) return;

		var splitExp  = this.expression.split(".");
		splitExp.shift();  // remove off selectedArc prefix in expression

		if (newValue != null && typeof(newValue) === "object") {
			newValue = TJSON.parse(TJSON.encode(newValue));
		}
	
		inspectPropertyChainLookup.setupProperty( _inspectedArc,  splitExp.join(".") );
	
		var result = inspectPropertyChainLookup.setPropertyChainValue(newValue);
		
		//console.log( splitExp.join(".")+" = ", ""+result);
	
		/*  // todo: update arc appearance if required
		var leafProp = splitExp[splitExp.length - 1];
		
		if ( vueModel.gotLocation && leafBindingHash[leafProp] ) {
			updateRelatedNodesOfModel(myDiagram.model, _inspectedNodeVal.def, leafBindingHash[leafProp]);
		}
		*/
	
	});
	
	
	Vue.directive('node', function(newValue, oldValue) {
		if (_inspectedNodeVal == null) return;
		
	//	if (newValue === undefined) return;  // if value is strictly undefined, can process be skipped?
		
		var splitExp  = this.expression.split(".");
		splitExp.shift();  // remove off selected prefix in expression

		if (newValue != null && typeof(newValue) === "object") {
			newValue = TJSON.parse(TJSON.encode(newValue));
		}
		
		inspectPropertyChainLookup.setupProperty( _inspectedNodeVal,  splitExp.join(".") );
		var result = inspectPropertyChainLookup.setPropertyChainValue(newValue);
		
		var leafProp = splitExp[splitExp.length - 1];
		
		if ( vueModel.gotLocation && leafBindingHash[leafProp] ) {
			updateRelatedNodesOfModel(myDiagram.model, _inspectedNodeVal.def, leafBindingHash[leafProp]);
		}
	});
	
	
	// Vuemodel for minimal selected LocationPacket containing LocationDefinition only
	var vueModelData;
	function setupNewVueModelData() {  // Default vueModel template
		return (vueModelData= {  
			gotLocation:false, 
			isProto:false,
			multiSelectedLocations:false,
			selectedArc: null,
			selected: { x:0, y:0, z:0, def: $.extend(true, {}, gui._guiGlueParams) }, 
			locationDefIds:world.getLocationDefinitionIds(world.getDefaultLocationDefIdHash())	
		});
	}
	
	var vueModel = new Vue({
		el:".dg.ac",
		data: setupNewVueModelData(),
		methods: {
			addLocationDefOverwrite: function(prop, e) {
				var result = this.$get("selected.def."+prop);
				if (result != null && typeof result === "object") {
					result = $.extend(true, {}, result);
					
				}
				if (result == null) {
					var datGui =$(e.target).data("dat-gui");
					if (datGui._guiGlueParams) {
					
						result = $.extend(true, {}, datGui._guiGlueParams);
					}
					else {
						result = datGui._guiGlue.value;
					}
					//alert();
					
					//result = 
				
				}
				//alert("adding: selected.defOverwrites."+prop+"="+result);
				this.$set("selected.defOverwrites."+prop, result );
			}
			,removeLocationDefOverwrite: function(prop) {
				var overwrites = this.$get("selected.defOverwrites");
				//alert("adding: selected.defOverwrites."+prop+"="+result);
				var propArr = prop.split(".");
				var leafProp = propArr.pop();
				
				if (propArr.length) {
					alert("THis should not happen under this our case!");
					Vue.delete( this.$get("selected.defOverwrites."+propArr.join(".")), leafProp);
				}
				else {
					Vue.delete( overwrites, leafProp );
				}
				
				var p;
				for (p in overwrites) {
					if (p!= null) return;
				}
				Vue.delete(this.selected, "defOverwrites");
				
				
				//
			}
		}
	});
	
	function inspectGoArc(goArc) { 
		var arc = goArc._arc;
		_inspectedArc = arc;

		var newVueModelData;
		if (arc.val != null) {
			var jsonStr = TJSON.encode(arc.val);
			newVueModelData = TJSON.parse(jsonStr);  // consider todo: should this be a plain JSON parse?
		}
		else {
			newVueModelData  = null;
		}

		//console.log("New vue model:"+ newVueModelData);
		vueModel.selectedArc = { val:newVueModelData }; //, cost:arc.cost
	}
	

	var lastInspectedLocDef = null;
	function inspectGoNode(goNode) {
		
		//allLocationGUIDom.removeAttr("hidden");
		vueModel.isProto = goNode.isProto;
	
		vueModel.gotLocation = true;
		//guiOverwriter.domElement.removeAttribute("hidden");
		
		var node = goNode._node;
		_inspectedGoNodeData = goNode;
		
		var nodeVal = node.val;
		_inspectedNodeVal = nodeVal;
		

		
		// consider todo: check if locDef is changed, if not changed no need to update
		var locDef = nodeVal.def;
		
		if (lastInspectedLocDef != locDef) {
			// reset temporary view-cache UI state values when location definition inspection-target changes
			resetAllGUISubInstances(); 
		}
		lastInspectedLocDef = locDef;
		// lazy JSON approach to convert a Model to vueModel
	
		//console.log("Inspecting", locDef);
	
		// setup new location def
		var jsonStr = TJSON.encode(nodeVal);  
		var newVueModelData = TJSON.parse(jsonStr);  // consider todo: should this be a plain JSON parse?
		//alert(newVueModelData instanceof LocationPacket);
		vueModel.selected = newVueModelData;

		// nodeVal.state
	}

	function setupGUIGeneric(gui) {
		gui.domElement.addEventListener('dragstart', onUIDragStart);
		gui.domElement.addEventListener('dragstop', onUIDragStop);
		allLocationGUIDom = allLocationGUIDom.add($(gui.domElement));
		return gui;
	}
  
	// GOJS
    if (window.goSamples) goSamples();  // init for these samples -- you don't need to call this

    // Note that we do not use $ here as an alias for go.GraphObject.make because we are using $ for jQuery
    var GO = go.GraphObject.make;  // for conciseness in defining templates

    myDiagram =
      GO(go.Diagram, "myDiagramDiv",  // must name or refer to the DIV HTML element
         { allowDrop: true,
			
		 	"undoManager.isEnabled": true,
                    "toolManager.hoverDelay": 100  // how quickly tooltips are shown
		 
		 }
		 
		);  // must be true to accept drops from the Palette
	myDiagram.mouseDrop = function(e, node) {

		  var it = myDiagram.toolManager.draggingTool.copiedParts;
		  if (it == null) {
			return;
		  }
		  it = it.iterator;
		  while (it.next()) {
				if (it.key instanceof go.Node) { 
					scaleNode(it.key, myDiagram.scale);
				}
				else if (it.key instanceof go.Link) {
					scaleLink(it.key, myDiagram.scale);
				}
		  }
		  

	}
	
	//myDiagram.linkTemplate.curve = go.Link.Bezier;
	 myDiagram.linkTemplate = GO(go.Link,
      { routing: go.Link.Normal, toShortLength: 4, selectable: true },
      GO(go.Shape,
        { isPanelMain: true, stroke: "black", strokeWidth: 1 },
        // the Shape.stroke color depends on whether Link.isHighlighted is true
        new go.Binding("stroke", "isHighlighted", function(h) { return h ? "red" : "black"; })
            .ofObject()),
      GO(go.Shape,
        { toArrow: "standard", stroke: null, strokeWidth: 0, name:"arrow" },
        // the Shape.fill color depends on whether Link.isHighlighted is true
        new go.Binding("fill", "isHighlighted", function(h) { return h ? "red" : "black"; }).ofObject())
    );
	myDiagram.linkTemplate.curviness = 1;
	//myDiagram.linkTemplate.bind(new go.Binding("curviness", "curviness"));

	myDiagram.addLayerBefore(GO(go.Layer, {name:"Regions"}), myDiagram.findLayer(""));
	myDiagram.addLayerAfter(GO(go.Layer, {name:"Points"}), myDiagram.findLayer(""));
	
    // define several shared Brushes
    var fill1 = "rgb(243,134,48)"
    var brush1 = "rgb(203,84,08)";

    var fill2 = "rgba(167,219,216, .65)"
    var brush2 = "rgb(127,179,176)";

    var fill3 = "rgba(224,228,204, .5)"
    var brush3 = "rgb(184,188,164)";
	
	//  var fill1 = "rgb(243,210,231)"
//   var brush1 = "rgb(65,180,181)";
 //  var fill2 = "rgba(167,219,216, .85)"
 //   var brush2 = "rgb(127,179,176)";


   // var fill4 = "rgb(243,134,48)"
 //   var brush4 = "rgb(203,84,08)";
	
	var TEXTLABEL_BASEWIDTH = 80;
	var MAX_SHAPE_SIZE = 512;
	var POINT_SIZE = 5;
	
	function getNodeTemplate(figure, fill, stroke, maxSize, layout, layerName) {
	
		var panelLayout = layout ? layout :  go.Panel.Vertical;
		if (!layerName) layerName = "";
		
		var textBlockParams = [go.TextBlock,
			{ 
			maxSize: new go.Size(TEXTLABEL_BASEWIDTH, NaN),
			wrap: go.TextBlock.WrapFit,
			textAlign: "center",
			editable: false,
			pickable: false,
			portId:"",
			font: "bold 7pt Arial, sans-serif",
			name: "TEXT" , portId:""
			},
			new go.Binding("text", "text" ).makeTwoWay()
		
		];
		
		textBlockParams.push(
				   new go.Binding("pickable", "", function(data) {
			
						return myDiagram.scale < 1;
				  })
		  );
			
		///*
		//if (panelLayout === go.Panel.Spot) {
			textBlockParams.push(
				   new go.Binding("fromLinkable", "", function(data) {
						return myDiagram.model.modelData.linkable;
				  }),
					new go.Binding("toLinkable", "", function(data) {
						return myDiagram.model.modelData.linkable;
				  })
		  );
		//}
		//*/
		var textBlock  =  GO.apply(null, textBlockParams);

		
				
		var shape = GO(go.Shape, "Ellipse",
			  { strokeWidth: 2, fill: fill1, name: "SHAPE"
			 , desiredSize: new go.Size(16, 16)
			 ,minSize:  new go.Size(1,1)
				,maxSize:  new go.Size(maxSize ? maxSize : NaN, maxSize  ? maxSize : NaN)
				,figure:figure
				,fill:fill
				,stroke:stroke
				,portId: "", cursor: "pointer",  // the Shape is the port, not the whole Node
				// allow all kinds of links from and to this port
			  fromLinkableSelfNode: false, fromLinkableDuplicates: false,
			   toLinkableSelfNode: false, toLinkableDuplicates: false
			   
			  },
			  
			 // new go.Binding("figure", "figure"),
			  
			 //new go.Binding("fill", "fill"),
			 // new go.Binding("stroke", "stroke"),
			   
			 new go.Binding("desiredSize", "", function(v) { return v._node ? getUniformSize(v._node.val.defOverwrites && v._node.val.defOverwrites.size ?v._node.val.defOverwrites.size : v._node.val.def.size) : v.size; } )
			  ,
				   new go.Binding("fromLinkable", "", function(data) {
						return myDiagram.model.modelData.linkable;
				  }),
					new go.Binding("toLinkable", "", function(data) {
						return myDiagram.model.modelData.linkable;
				  })
			  
			  );
			 
		var goParams = [go.Node, panelLayout,
        { locationSpot: go.Spot.Center },
        new go.Binding("location", "loc").makeTwoWay(), new go.Binding("category", "", function(v) {  return v._node ? getCategoryStringFromType(v._node.val.defOverwrites && v._node.val.defOverwrites.type!=null ? v._node.val.defOverwrites.type : v._node.val.def.type) : v.category; }  ) ];
			
		if (panelLayout == go.Panel.Spot)  {
			goParams.push(shape, textBlock);
		}
		else {
			goParams.push(textBlock, shape);
		}
		
		goParams.push({layerName:layerName});
		
		
		return GO.apply(null, goParams);
	}



	 myDiagram.nodeTemplateMap.add("point", getNodeTemplate("Square",fill1,brush1, POINT_SIZE, null, "Points"));
	  myDiagram.nodeTemplateMap.add("path", getNodeTemplate("Diamond",fill2,brush2, MAX_SHAPE_SIZE, null, ""));
	  myDiagram.nodeTemplateMap.add("region",getNodeTemplate("Circle",fill3,brush3, MAX_SHAPE_SIZE, go.Panel.Spot, "Regions"));

	  function scaleLink(link, newscale) {
		link.curviness = 1 * origscale/newscale;
	  }
	  function scaleNode(node, newscale) {
	  	//origscale / newscale;
			
			var text = node.findObject("TEXT");
			text.scale =  origscale / newscale;//newscale < .5 ? origscale / newscale*.5 : 1;
			text.visible = newscale >= .1 ? true : false; 
			text.maxSize.width = TEXTLABEL_BASEWIDTH * origscale / newscale;
			if (node.category === "point") {
				var shape = node.findObject("SHAPE");
				shape.scale =  newscale >= .3 ? 1 :  origscale / newscale * .3;
			}
			else if (node.category === "path") {
				var shape = node.findObject("SHAPE");
				var curSize = shape.desiredSize.width >= MAX_SHAPE_SIZE ? MAX_SHAPE_SIZE : shape.desiredSize.width;
				curSize *=newscale;
				shape.scale =  curSize >= 3 ? 1 : 3/curSize;
			}
	  }
	  
	  // This code keeps all nodes at a constant size in the viewport,
      // by adjusting for any scaling done by zooming in or out.
      // This code ignores simple Parts;
      // Links will automatically be rerouted as Nodes change size.
      var origscale = NaN;
      var oldscale = NaN;
      myDiagram.addDiagramListener("InitialLayoutCompleted", function(e) { origscale = oldscale = myDiagram.scale; });
      myDiagram.addDiagramListener("ViewportBoundsChanged", function(e) {
        if (isNaN(origscale)) return;
        var newscale = myDiagram.scale;
        if (oldscale === newscale) return;  // optimization: don't scale Nodes when just scrolling/panning
        oldscale = newscale; 
        myDiagram.skipsUndoManager = true;
        myDiagram.startTransaction("scale Nodes");
		
		//myDiagram.linkTemplate = myDiagram.linkTemplate;
		
        myDiagram.nodes.each(function(node) {  // consider todo: only perform for nodes within visibility set? need to form visibilty set per scroll though.
		
			scaleNode(node, newscale);
			
          });
		  
		   myDiagram.links.each(function(link) {  // consider todo: only perform for nodes within visibility set? need to form visibilty set per scroll though.
		
			scaleLink(link, newscale);
			
          });
		  
		  
		 // myDiagram.model.updateTargetBindings("
        myDiagram.commitTransaction("scale Nodes");
        myDiagram.skipsUndoManager = false;
		
      });
	  
	  
	
	function writePropertiesOver(obj, src) {
		var p;
		if (src == null) return obj;
		for(p in src) {
		
			obj[p] = src[p];
		}
		return obj;
	}
		  
	var textProxy = {
	   get : function() {
			return this._node && this._node.val.defOverwrites != null && this._node.val.defOverwrites.label  ? this._node.val.defOverwrites.label : this._node.val.def.label;
	   },
	   set : function(val) {
			var prefix = val.charAt(0);
			if (prefix=== "#") {	// lookup location definition
				val = val.slice(1);
				var tryDef = world.getLocationDef( val );
				if (tryDef != null) {
					this._node.val.def = tryDef;
					this._node.val.defOverwrites = null;
					this.isProto =  val =="Point" || val ==="Path" || val === "Region";
					inspectGoNode(this);
				}
				else {
					alert("Failed to find location definition: "+val);
				}
			}
			else if (prefix === "~") {  // write label directly into location definition
				if (this.isProto || val =="Point" || val ==="Path" || val === "Region") {
					alert("Sorry, cannot write label directly into prototype location definition id! Save it first with * prefix!");
					return;
				}
				val = val.slice(1);
				if (val === "" ) val = this._node.val.def.label;
				if (this._node.val.defOverwrites != null) {
					delete this._node.val.defOverwrites["label"];
				}
				this._node.val.def.label = val;
			}
			else if (prefix === "*") { // save location definition
				val = val.slice(1);
				//
				var dupLoc;
				
				if (val.charAt(0) === "#") {
					val = val.slice(1);
					if (val === "") {
						if (this.isProto || this._node.val.def.id =="Point" || this._node.val.def.id ==="Path" || this._node.val.def.id === "Region") {
							alert("Sorry, cannot write directly into prototype location definition! Save it first with * prefix!");
							return;
						}
						else writePropertiesOver(this._node.val.def , this._node.val.defOverwrites);
						this._node.val.defOverwrites = null;
						return;
					}
					dupLoc = writePropertiesOver( world.getDuplicationLocationDef(this._node.val.def, val) , this._node.val.defOverwrites);
				}
				else {
					if (val === "") {
						if (this.isProto || this._node.val.def.id =="Point" || this._node.val.def.id ==="Path" || this._node.val.def.id === "Region") {
							alert("Sorry, cannot write directly into prototype location definition! Save it first with * prefix!");
							return;
						}
						else writePropertiesOver(this._node.val.def , this._node.val.defOverwrites);
						this._node.val.defOverwrites = null;
						inspectGoNode(this);
						
						return;
					}
					
					
					if (this._node.val.defOverwrites == null) {
						//this._node.val.defOverwrites = {};
					
						this._node.val.setEmptyDefOverwrites();

					}
					this._node.val.defOverwrites.label = val;
					dupLoc = writePropertiesOver( world.getDuplicationLocationDef(this._node.val.def, val) , this._node.val.defOverwrites);
				}
			
				try {
					world.addLocationDef(dupLoc);
					vueModel.locationDefIds.push(dupLoc.id);
					this._node.val.defOverwrites = null;
					this._node.val.def = dupLoc;
					
					this.isProto = false;
					inspectGoNode(this);
				}
				catch(err) {
					alert(err);
				}
				
			}
			else if (prefix === "^") {
			
				if (this.isProto || this._node.val.def.id =="Point" || this._node.val.def.id ==="Path" || this._node.val.def.id === "Region") {
					alert("Sorry, cannot rename directly into prototype location definition! Save it first with * prefix!");
					return;
				}
						
						
				val = val.slice(1);
				
				if (val.charAt(0) === "#") {  
					val = val.slice(1);
					if (val ===this._node.val.def.id) {
						return;
					}
					
					if (val === "") {  // TODO: delete
						alert("TODO: deletion of location definition");
						return;
					}
					else {
					
						if ( world.getLocationDef(val) == null ) {  // rename
							world.removeLocationDef(this._node.val.def);
							vueModel.locationDefIds.$set( vueModel.locationDefIds.indexOf(this._node.val.def.id), val);
							this._node.val.def.id = val;
							world.addLocationDef(this._node.val.def);
						}
						else { // consider todo: check trashed definition
							return;
						}
						inspectGoNode(this);
						return;
					}
				}
				else {
					return;
				}
			}
			else {  // write label overwrite
				if (val =="Point" || val ==="Path" || val === "Region") {
					alert("Sorry, prototype id value reserved");
					return;
				}
				if (val === "") {
					if (this._node.val.defOverwrites != null) {
						delete this._node.val.defOverwrites["label"];
						
						
					}
					val = this._node.val.def.label;
					this.isProto =  val =="Point" || val ==="Path" || val === "Region";
					return;
				}
				if (this._node.val.defOverwrites == null) {
					//	this._node.val.defOverwrites = { label: val };
					this._node.val.setEmptyDefOverwrites();
					this._node.val.defOverwrites.label = val;
				}
				else this._node.val.defOverwrites.label = val;
				//this._node.val.def.label = val;
			
			}
	   }
	};
	
	
					
	function updateRelatedNodesOfModel(model, def, prop) {
		var nodeDataArr = model.nodeDataArray;
		var i = nodeDataArr.length;
		var o;
		while(--i > -1) {
			o = nodeDataArr[i];
			if (o._node && o._node.val.def === def) model.updateTargetBindings(nodeDataArr[i], prop);
		}
	}
	
	function vueNullifyPropertyOnInstanceChain(expression) {
		var exprSplit = expression.split(".");
		if (exprSplit.length >= 3) {
		
			var leaf = exprSplit.pop();
			
			nullifyPropertyOnInstanceChain(  vueModel.$get(exprSplit.join(".")), leaf, vueModel.$get(exprSplit.slice(0, exprSplit.length-1).join(".") ), exprSplit[exprSplit.length-1] );
		}
		else {
			nullifyPropertyOnInstanceChain( vueModel.$get(exprSplit[0].toString()),  exprSplit[1].toString());
		}
	}
	
	function nullifyPropertyOnInstanceChain(instance, prop, parentObj, instanceProp) {
		if (instance == null) return true;
		if (instance[prop] !== undefined) instance[prop] = null;
		
		if (parentObj != null) {
			var p;
			for (p in instance) {
				if (instance[p] != null) {
					return true;
				}
			}
			parentObj[instanceProp] = null;
			return false;
		}
		
		return true;
	}
	
	
	function addDiagramLink(params) {
		var fromNode = myDiagram.findNodeForKey(params.from).data._node;
		fromNode.addArc(myDiagram.findNodeForKey(params.to).data._node);
		params._arc = fromNode.arcList;
		
		return fromNode.arcList;
	
	}
	function removeDiagramLink(params) {
		var fromTest =  myDiagram.findNodeForKey(params.from);
		var targTest = myDiagram.findNodeForKey(params.to);
		if (fromTest ===null || targTest == null) {  // hmm..GOJS, is this intended? WHy is it null?
			//alert("TARGEST NULL FOUND:"+[params.from, params.to]);
			return;
		}
		
		var resultTest =fromTest.data._node.removeArc( 	targTest.data._node  );
		//alert(resultTest + ", <- removeDiagramLink");
		if (!resultTest) alert("removeDiagramLink de.polygonal operation failed exception!");
		return resultTest;
	}
	
	
	function testResultAssert(testResult, str) {
		if (!testResult) {
			alert("testResultAssert failed:"+str);
		}
		//else alert("SUCCESS:"+str);
		return testResult;
	}
	
  myDiagram.model.linkKeyProperty = "key";
  myDiagram.model.addChangedListener(function(e) {
    if (e.isTransactionFinished) {
      var tx = e.object;
	  
      if (tx instanceof go.Transaction && console && e.model) {
       // console.log(tx.toString());
		
		if (true || tx.name != "Move") {
		
			var methodToCalls = [];
			var nodesToAdd = [];
			var arcsToAdd = [];
			tx.changes.each(function(c) {
			
			  if (c.model) {
				if ( c.model === c.object ) { // deemed insertion or removal
					if (c.newValue != null && c.oldValue == null) {  // insertion infered
					
						if (c.propertyName == "nodeDataArray") {  // insert node
							nodesToAdd.push( c.newValue );
						}
						else if (c.propertyName == "linkDataArray") {  // create link
						
							arcsToAdd.push(c.newValue);
							//console.log("LINK CREATED:", c.newValue);
							
						}
					}
					else if (c.newValue == null && c.oldValue != null) { // removal infered
						if (c.propertyName == "nodeDataArray") {  // remove node
							//console.log("REMOVE NODE:", c.oldValue);
							//myDiagram.findNodeForKey(c.
							world.graph.removeNode( c.oldValue._node );
							testResultAssert(  world.removeHashEditable(c.oldValue._node), "Remove node" );
						}
						else if (c.propertyName == "linkDataArray") {  // remove link
							removeDiagramLink(c.oldValue);
							testResultAssert(  world.removeHashEditable(c.oldValue._arc), "Remove arc" );
						}
					}
					else {
						console.log	("Could not resolve this transaction case: "+tx);
					}
				}
				else {  // deemed modifying of data within model
					if (c.propertyName === "loc") {   // moving 
						var n = c.object._node;
						if (n != null) {
							n.val.x = c.newValue.x;
							n.val.y = c.newValue.y;
							if (_selectedGoNodeData === c.object) {  // sync location with vue gui
								vueModel.selected.x = c.newValue.x;
								vueModel.selected.y = c.newValue.y;
							}
							///vueModel.val.x = c.newValue.x;
							//vueModel.val.y = 
						}
					}
					else if (c.propertyName === "linkable") {
						// irreleavant. do nothing
					}
					else if (c.propertyName === "text") {
						methodToCalls.push(updateRelatedNodesOfModel, [e.model, c.object._node.val.def, "text"]);
						methodToCalls.push(updateRelatedNodesOfModel, [myPalette.model, c.object._node.val.def, "text"]);
						var n = c.object._node;
						if (n != null && n.val=== _inspectedNodeVal  ) {
							if(n.val.defOverwrites && n.val.defOverwrites.label!=null) {
								vueModel.$set("selected.defOverwrites.label", n.val.defOverwrites.label);
							}
							else {
								vueNullifyPropertyOnInstanceChain("selected.defOverwrites.label");
							}
							vueModel.$set("selected.def.label", n.val.def.label);
							
						}
					}
					else if (c.propertyName === "size") {

					}
					else if (c.propertyName === "_node") {
						// irrelavant
						alert("_node :: UNderscored property should not detect");
					}
					else if (c.propertyName === "category") {
						// irrelavant
					}
					else { //
					  alert("could not resolve:"+c.propertyName);
					}
				}

				console.log( c.object," " +c.modelChange + ","+c.propertyName+","+c.oldParam +", "+c.newParam );
				//console.log("OldValue:", c.oldValue);
				//console.log("NewValue:", c.newValue);
				
				//console.log( model.toIncrementalJson(e) );
			  }
			});
			
			var i;
			for(i=0; i< methodToCalls.length; i+=2) {
				methodToCalls[i].apply(null, methodToCalls[i+1]);
			
			}
			
			// creation of nodes
				i = 0;
					var v;
				var o;
				for (i=0; i<nodesToAdd.length; i++) {
					o =nodesToAdd[i];
					if (o._node != null) {  // DUPLICATE NODE CASE
						//alert(flagDownKeys );
						//e.model.setDataProperty(o,"_node",v= world.addLocationNode(world.getLocationDef(o._node.val.def.id), o.loc.x, o.loc.y, 0, null, ( false ? o._node.val.cloneOverwritesDynamic() : o._node.val.defOverwrites) ));
						o._node = v = world.addLocationNode(world.getLocationDef(o._node.val.def.id), o.loc.x, o.loc.y, 0, null, ( false ? o._node.val.cloneOverwritesDynamic() : o._node.val.defOverwrites) );
						
						world.registerHashEditable(v, o);
					}
					else {  // NEW NODE CASE
						
						//e.model.setDataProperty(o,"_node",v= world.addLocationNode(world.getLocationDef(o.locid).setSize(o.size.width), o.loc.x, o.loc.y, 0, null, null ));
						o._node = v = world.addLocationNode(world.getLocationDef(o.locid).setSize(o.size.width), o.loc.x, o.loc.y, 0, null, null );
						if (o.defOverwrites != null) {
							o._node.val.setupNewDefOverwrites(o.defOverwrites);
						}
						world.registerHashEditable(v, o);
					}
					
					
					if (_selectedGoNodeData === o) {
						//alert("A");
						inspectGoNode(o);
					}
					
					if (o.text != textProxy) {
						Object.defineProperty(o,"text",textProxy);
						e.model.updateTargetBindings(o, "text");
					}
			
				}
				
				
				// creation of arcs
				i = 0;
				for (i = 0; i < arcsToAdd.length; i++) {
					o =arcsToAdd[i];
					world.registerHashEditable( addDiagramLink(o), o);
					if (_selectedGoArcData === o) {
						inspectGoArc(o);
					}
				}
	
		  }
		//  /*
		  else  {   // DEPRECIATED atm due to recursion problem with toIncrementalJSON
			//	/*
				console.log( e.model.toIncrementalJson(e) );
				var moveJson = e.model.toIncrementalJson(e);
				moveJson = JSON.parse(moveJson);
				var modData = moveJson.modifiedNodeData;
				
				var i =modData ?  modData.length : 0;
				var o;
				while(--i > -1) { // readonly
					o = modData[i];
					//= o.loc.x;
					//= o.loc.y;
					
				}
				//*/
	
				
				
		  }
		//  */
	  }
	  
    }
  });
		  
	function classify(instance) {
		instance["class"] = "awawaawtwaaw";
		return instance;
	}


    // initialize the Palette that is in a floating, draggable HTML container
    myPalette = new go.Palette("myPaletteDiv");  // must name or refer to the DIV HTML element
	myPalette.allowZoom = false;
	
//	palTemplate.findObject("SHAPE").maxSize = new go.Size(20,20);
	myPalette.nodeTemplateMap.add("point", getNodeTemplate("Square",fill1,brush1,20));
	 myPalette.nodeTemplateMap.add("path", getNodeTemplate("Diamond",fill2,brush2,20));
	 myPalette.nodeTemplateMap.add("region",getNodeTemplate("Circle",fill3,brush3,20));
	  
  	
	  
    myPalette.model = new go.GraphLinksModel([
      { locid:"Point", isProto:true, text:"Point", category:"point",  size:new go.Size(POINT_SIZE,POINT_SIZE)   },
      { locid:"Path", isProto:true, text:"Path",  category:"path",  size:new go.Size(12,12) },
      { locid:"Region", isProto:true,  text:"Region",  category:"region", size:new go.Size(30,30) }
    ]);
	
	var FLAG_SHIFT_DOWN = 1;
	var flagDownKeys = 0;
	
	jQuery(window).keydown( function(e) {
		if (e.keyCode === 16) {	 // shift
			flagDownKeys |= FLAG_SHIFT_DOWN;
			myDiagram.model.setDataProperty(myDiagram.model.modelData, "linkable", true);
			
		}
		//console.log(flagDownKeys);
	});
	jQuery(window).keyup( function(e) {
		if (e.keyCode === 16) {  // shift
			flagDownKeys &= ~FLAG_SHIFT_DOWN;
			myDiagram.model.setDataProperty(myDiagram.model.modelData, "linkable", false);
		}
	//	console.log(flagDownKeys);
		
		 
	});

    myPalette.addDiagramListener("InitialLayoutCompleted", function(diagramEvent) {
      var pdrag = document.getElementById("paletteDraggable");
      var palette = diagramEvent.diagram;
      var paddingHorizontal = palette.padding.left + palette.padding.right;
      var paddingVertical = palette.padding.top + palette.padding.bottom;
	  pdrag.style.top = 8  + "px";
	  pdrag.style.left = 270  + "px";
      pdrag.style.width = palette.documentBounds.width + 20  + "px";
      pdrag.style.height = palette.documentBounds.height + 40 + "px";
    });
	
	$("#infoDraggable").focus( function() {
		
	});
	
	myDiagramDivs = $("#myDiagramDiv").add($("#myPaletteDiv"));
	
	function getMultiSelectedLocations(diagramSelection) {
		var arr = [];
		 var it = diagramSelection.iterator;
		 var selection;
		  while (it.next()) {
			selection = it.value;
			if ( (selection instanceof go.Node) && selection.data && selection.data._node ) {
				arr.push(selection.data.key);
			}
		  }
		return arr.length > 1 ? arr : false;
	}
	
	// handles either node or arc selection (<- bleh this method is badly  contructed)...
	myDiagram.addDiagramListener("ChangedSelection", function(e) {
		var selection = myDiagram.selection.first();
		
		myDiagram.clearHighlighteds();
		
		if (selection instanceof go.Link) {
			_inspectedNodeVal = null;
			_selectedGoNodeData = null;
			vueModel.gotLocation = false;
			vueModel.selected = null; 
			_selectedGoArcData = selection.data;
			
			selection.isHighlighted  = true;
			
			if (selection.data._arc == null) {
				vueModel.selectedArc = null;
				return;
			}
			inspectGoArc(selection.data);
			
			return;
		}

		_inspectedArc = null;
		_selectedGoArcData = null;
		vueModel.selectedArc = null;
		
		if (selection != null) {
			vueModel.multiSelectedLocations = getMultiSelectedLocations(myDiagram.selection);
		}
		else {
			vueModel.multiSelectedLocations = false;
		}
		
		
		  if (selection === null || !(selection instanceof go.Node) || !selection.data || !selection.data._node ) {  // hide UIs
			_inspectedNodeVal = null;
			if (selection && selection.data != null) _selectedGoNodeData = selection.data
			vueModel.gotLocation = false;
			vueModel.selected = null; 
			 
			return;
		}
		
		
		
		_selectedGoNodeData = selection.data;
		inspectGoNode(selection.data);

	
	});
	
	
	
	myPalette.addDiagramListener("ChangedSelection", function(e) {
		var selection = myPalette.selection.first();
		
		if (selection != null) {

			vuePalette.gotNonProtoSelection = !worldProtoLocIds[selection.data.text];
		}
	
	});
	
	

	var vuePalette;

    $(function() {
        $("#paletteDraggable").draggable({handle: "#paletteDraggableHandle", start:onUIDragStart, stop:onUIDragStop}).resizable({
          // After resizing, perform another layout to fit everything in the palette's viewport
		  start: onUIDragStart,
          stop: function(){ myPalette.layoutDiagram(true); onUIDragStop(); }
        });

		
        var inspector = new Inspector('infoDraggable', myDiagram,
          {
            
		  acceptButton: true,
            resetButton: true
          // /*
			, propertyNames: {
		//		"Node": ["category"],
              //"Node": ["location", "background", "scale", "angle", "isShadowed", "resizable"],
              //"#SHAPE": ["fill", "stroke", "strokeWidth", "figure"],
              "#TEXT": ["text"]
            }
			//*/
          });
		  
		 
		  var inspectorBtnContainer = $("#infoDraggable .inspector-button-container");
		  inspectorBtnContainer.after($('<div id="prefix-btn-container"></div>'));
		  var prefixBtnContainer = $("#prefix-btn-container");
		  prefixBtnContainer.append($('<button>~</button>').attr("v-on:click", "addTextPrefix('~')"));
		  prefixBtnContainer.append($('<button>*</button>').attr("v-on:click", "addTextPrefix('*')") );
		  prefixBtnContainer.append($('<button>*#</button>').attr("v-on:click", "addTextPrefix('*#')") );
		  prefixBtnContainer.append($('<button>^#</button>').attr("v-on:click", "addTextPrefix('^#')") );
		  prefixBtnContainer.attr("v-show", "gotLocation");
		  prefixBtnContainer.after('<div style="clear:both"></div><hr/>');
		  
		 inspectorBtnContainer =  $("#infoDraggable");
		  inspectorBtnContainer.append('<div class="formelem"><label>#</label><select style="width:70%" v-on:change="loadSelectedLocationDef" v-model="selectedLocationDefId"><option v-for="id in locationDefIds" value="{{id}}">{{id}}</option></select><button v-show="gotLocation" v-on:click="loadSelectedLocationDef">Load</button><button v-show="gotLocation && selectedLocationDefId!=null" v-on:click="applySelectedLocationDef">Apply{{ multiSelectedLocations ? " to all" : ""}}</button><button v-show="!gotLocation" v-on:click="editSelectedLocationDef">Edit</button></div><hr/>'); 
		
		 inspectorBtnContainer.append(prefixBtnContainer = $('<div v-show="gotLocation"></div>'));
		
		
		 prefixBtnContainer.append('<div class="formelem"><label style="">Query</label><select style="min-width:60%"></select><button>Go</button></div>'); 
		 
		
		  vuePalette = new Vue({ 
			el:"#paletteDraggable",
			data: {
				vueData: vueModelData,
				palHash: {},
				gotNonProtoSelection:false
			},
			methods: {
				addToPalette: function() {
					//
					if (!this.vueData.gotLocation) {
						 alert("No location selected!");
						 return;
					}
					if (!this.vueData.isProto) {
						// ok
					}
					else {
						if (this.vueData.selected.defOverwrites && this.vueData.selected.defOverwrites.label && !worldProtoLocIds[this.vueData.selected.defOverwrites.label] ) {
							// ok
						}
						else {
							alert("Can't add to pallette, use a different overwrite text label first!");
							return;
						}
					}
					var type = this.$get("vueData.selected.defOverwrites.type");
					if (type == null) type = this.vueData.selected.def.type;
					var catType;
					type = catType= LocationDefinition.getLocationDefinitionTypeLabel(type);
					var texter = (this.$get("vueData.selected.defOverwrites.label") || this.vueData.selected.def.label) ;
					var key =  texter + type;
					if (this.palHash[key]) {
						//myPalette.model.removeNodeData(this.palHash[key]);
						alert("Already registered to palette something similar..");
						return;
					}
					
					
					var selFirst = myDiagram.selection.first();
					
					var clonedSelection = selFirst.copy();
					var nodeToClone = clonedSelection.data._node;
					
					var copyData =$.extend(false, {text:texter}, clonedSelection.data);
	
						
					copyData._node = null;
					copyData.category = catType.toLowerCase();
					copyData.text = texter;
					copyData.defOverwrites = nodeToClone.val.defOverwrites ?  $.extend(true, {}, nodeToClone.val.defOverwrites) : null; 
					copyData.locid = nodeToClone.val.def.id;
					clonedSelection.data = copyData;
					
		
					//delete copyData["key"];// = null;
					//alert( myPalette.model.getKeyForNodeData(copyData) );
					
					this.palHash[key] =  copyData;
					//	myPalette.add(copy);
			
					myPalette.add(clonedSelection);
					//myPalette.model.addNodeData(copyData);
					
					
				}
			},
			removeFromPalette: function() {
				
			}
		 });
		 
		var vuePanel = new Vue({
			el:"#infoDraggable",
			data: vueModelData,
			methods: {
				addTextPrefix: function(prefix) {
					var inputText = jQuery("#infoDraggable > .inspector >  .inspector-section input[type='text']");
					if (!inputText.length) 
					{
						alert("addTextPrefix() Exception:: Could not find inputText");
						return;
					}
					var curVal = inputText.val();
					var sect2;
					
					sect2 = curVal.slice(2);
					curVal = curVal.slice(0,2);
					curVal = curVal.replace(/\*|\#|\^|\~/g, "");
					curVal = prefix + curVal+sect2;
					inputText.val(curVal);
				},
				editSelectedLocationDef: function(e) {
					if (this.gotLocation) {
						alert("UI Exception: editSelectedLocationDef :: This should not be available! Only available without selected node location");
						return false;
					}
					if ( this.selectedLocationDefId ) {
						var locDef = world.getLocationDef(this.selectedLocationDefId);
						if (locDef == null) {
							alert("editSelectedLocationDef:: Location definition id not found exception: "+this.selectedLocationDefId);
							return;
						}
						if (this.selected && this.selected.def && this.selected.def.id === this.selectedLocationDefId) {   // toggle off instead
							this.selected  = null;
							_inspectedNodeVal = null;
						}
						else {   // regular case edit
							var jsonStr = TJSON.encode(locDef);
							var vueModelSelectedDef = TJSON.parse(jsonStr);
							_inspectedNodeVal = { def:locDef };
						
							this.selected =  { def:vueModelSelectedDef };
						}
	
					}
				}
				,loadSelectedLocationDef: function(e) {
					///*
					if (!this.gotLocation) {
						//alert("UI Exception: loadSelectedLocationDef :: This should not be available! Only available with selected node location");
						return false;
					}
					//*/
					if ( this.selectedLocationDefId ) {
						var inputText = jQuery("#infoDraggable > .inspector >  .inspector-section input[type='text']");
						inputText.val("#"+this.selectedLocationDefId);
					}
				}
				,applySelectedLocationDef: function(e) {
					///*
					if (!this.gotLocation) {
						alert("UI Exception: applyLocationDefinition :: This should not be available! Only available with selected node location");
						return false;
					}
					//*/
					if ( this.selectedLocationDefId ) {
						var locDef = world.getLocationDef(this.selectedLocationDefId);
						if (locDef == null) {
							alert("applyLocationDefinition:: Location definition id not found exception: "+this.selectedLocationDefId);
							return;
						}
						var nodeId;
						var nodeData;
						if (!this.multiSelectedLocations) {
						
							nodeData = _selectedGoNodeData; //myDiagram.model.findNodeDataForKey(nodeId);
							if (nodeData == null) {
								alert("applySelectedLocationDef():: _selectedGoNodeData data not found exception:: "+nodeId);
								return;
							}
							if (nodeData._node == null) {
								alert("applySelectedLocationDef():: Node data's de.polygonal node not found exception:: "+nodeId);
								return;
							}
							nodeData._node.val.def = locDef;
							nodeData.isProto = false;
							myDiagram.model.updateTargetBindings(nodeData, "text");
							inspectGoNode(nodeData);
						}
						else {
							var multiSelectedLocations = this.multiSelectedLocations;
							var i = multiSelectedLocations.length;
							if (i ==0) {
								alert("applySelectedLocationDef():: Exception empty array!");
								return;
							}
							while(--i > -1) {
								nodeId = multiSelectedLocations[i];
								nodeData = myDiagram.model.findNodeDataForKey(nodeId);
								if (nodeData == null) {
									alert("applySelectedLocationDef():: Node data not found exception:: "+nodeId);
									continue;
								}
								if (nodeData._node == null) {
									alert("applySelectedLocationDef():: Node data's de.polygonal node not found exception:: "+nodeId);
									continue;
								}
								nodeData._node.val.def = locDef;
								nodeData.isProto = false;
								myDiagram.model.updateTargetBindings(nodeData, "text");
							}
							//alert(multiSelectedLocations);
							
							inspectGoNode(nodeData);
						}
						
						
						
						
						
					}
				}
				
			}
		});
	
  
  
		  
        });
		
		

  }
  
})();
</script>



<style type="text/css">
.draggable {
  display: inline-block;
  vertical-align: top;
  border: 4px solid #BBB;
  border-radius: 4px;
  background-color: #F5F5F5;

  position: absolute;
  top: 20px;
  left: 120px;
  z-index: 500;
}

.dg textarea {
	font-size:12px;
}
.dg input[type=text] {
	font-size:12px;
}



.formelem {
	margin:5px 0;
}
.formelem input {
	display:inline-block;
	margin:0px 2px;

}
.formelem button {
	display:inline-block;
	margin:0px 2px;


}
.formelem label {
	display:inline-block;
	margin:0px 2px;

	
}
.formelem select {
	display:inline-block;
	width:auto;
	margin:0px 2px;

}

li.folder.bitmask ul {
	background-color:black;
}
li.folder.bitmask ul li.boolean {
	display:inline-block;
}
li.folder.bitmask ul li .property-name {
	width:auto;
}
li.folder.bitmask ul li.boolean .c {
	width:auto;
}

li.folder.bitmask ul li.title {
	whitespace:nowrap; 
}
li.folder.bitmask ul li.title .labellist {
 word-spacing: -2px;

 }
li.folder.bitmask ul li.title .labellist .prop {
	font-size:9px;
	color:magenta;
	margin:0 0px;
	

}

li.folder.instance > div > ul >  li.title {
	background-image:none;
	padding-left:8px;
}

li.folder.instance  > div > ul >  li.title:before {
	margin-right:8px;
	content:'\2611';
}

li.folder.instance  > div > ul.closed >  li.title:before {
	content:'\2610';
}



.handle {
  background-color: lightblue;
  cursor: move;
  text-align: center;
  font: bold 12px sans-serif;
}

#infoDraggable {
  font: 12px helvetica, sans-serif;
  background-color:rgba(45,45,45,.8);
}	

#infoDraggable .inspector {
	background-color:#000000;
	
	display:block;
}

#myInfo {
  padding: 6px;
}

#myPaletteDiv {
  background-color: #F5F5F5;
  width: 100%;
  height: 100%;
}

/*
One simple way of making a div fill its space,
with allowances for the title (top) and the resize handle (bottom)
*/
#paletteContainer {
  position:absolute;
  bottom: 14px;
  left: 0px;
  right: 0px;
  top: 14px;
}
#locationDefGUI > ul:before {
	content: 'location definition';
	display:block;
	padding-left:10px;
	background-color:#666666;	
}
#locationDefGUIOverwriter > ul:before {
	content: 'location overwrites';
	display:block;
	padding-left:10px;
	background-color:#666666;	
}
#locationStateGUI > ul:before {
	content: 'location state';
	display:block;
	padding-left:10px;
	background-color:#666666;	
}

.inspector-button-container {
	float:left;
	margin-left:0;
}
.inspector-button-container  input {
	margin:0;
}
#prefix-btn-container   button {
	margin:0;
	margin-top:6px;
	width:28px;
}
#prefix-btn-container {
	
	margin:0 auto;
	margin-left:0;
	padding-left:0;
	display:block;
	
	float:left;
	text-align:center;
}
#prefix-btn-container[hidden=hidden] {
	display:none;
}

#infoDraggableInstruct  {
	
}
#infoDraggableInstruct span {
	font-style:normal;	
	font-weight:bold;
	color:yellow;
}
#infoDraggableInstruct i {
	font-size:11px;
	font-weight:normal;
}
 canvas:focus{outline:none;}
 
 
.dg.main.disabled li.cr:hover:after, .dg.main.disabled li.folder.instance:hover:after {
	content:'Direct editing is disabled. * Save/Load into a new location definition id first on left sidepanel.';
	display:block;
	position:absolute;
	z-index:1;
	line-height:18px;
	right:20px;
	max-width:100px;
	background-color:black;
	padding:2px;
	
}

.dg.main li.folder.instance .overwritetrigger {
/*
	background-color:black;position:relative;z-index:1;top:0;left:0px;padding-left:10px;                 
*/
	}
.dg.main .property-name  {
	position:relative;
}
.dg.main .property-name .overwritetrigger, .dg.main li.folder.instance .overwritetrigger, .dg.main li.folder.bitmask .overwritetrigger {
	position:absolute;
	right:10px;
	width:auto;
	top:0px;
	color:rgb(127,179,176);
}
.dg.main li.folder.instance .overwritetrigger, .dg.main li.folder.bitmask .overwritetrigger {
	top:6px;
	z-index:1;
}
.dg.main li.folder {
	position:relative;
}
.dg.main .overwritetrigger {
	cursor:pointer;
}
.dg.main .overwritetrigger:hover {
	color:red !important;
}

.dg.main.disabled .c {
	pointer-events:none;
	opacity:.4;
}


.dg.main.disabled .folder.instance ul li.title {
	pointer-events:none;
	
}


.dg.main.disabled .folder.bitmask ul li {
	pointer-events:none;

}

 .dg.main.disabled input {
	background-color:black !important;
}



 .dg input[readonly=readonly] {
	color:yellow !important;
	background-color:black !important;
}

#btn_addToPal {
	position:absolute;
	bottom:-25px;
	left:0;
}
#btn_removeFromPal {
	position:absolute;
	bottom:-2px;
	left:-25px;
}

</style>
</head>
<body onload="init()" style="margin:0;padding:0">
<div id="sample">

    <div id="paletteDraggable" class="draggable" style="height: 300px;">
      <div id="paletteDraggableHandle" class="handle">Palette</div>
      <div id="paletteContainer">
        <div id="myPaletteDiv"></div>
      </div>
	 <button id="btn_addToPal" class="paletteBtn" v-on:click="addToPalette()" v-show="vueData.gotLocation">+</button>
	  <button id="btn_removeFromPal" class="paletteBtn" v-on:click="removeFromPalette()" v-show="gotNonProtoSelection">-</button>
    </div>

    <div style="display: block; z-index:0;vertical-align: top;  padding:0;margin:0;width:100%; height:100%;position:absolute; top;0; left:0;">
      <div id="myDiagramDiv" style="outline:none;background-color:whitesmoke;  margin:0 auto;	  width:100%; height: 100%"></div>
    </div>

    <div id="infoDraggable" style="position:relative; display: inline-block; vertical-align: top; padding: 5px; z-index:1">
      <div id="myInfo" style="visibility:visible; margin-bottom:10px;"><h1>Textifician Mapper</h1>Selecting a node in the Main Canvas will show linked location definition here</div>
	  <div id="infoDraggableInstruct" style="position:absolute;bottom:0;left:0;padding:5px;">
		 <h4>TEXT <span>prefix</span> legend:</h4>
		 <p>
		<span>(no prefix)</span> <i>Create overwrite label</i> <hr/>
		<span>~</span>  <i>Write label into existing location definition</i><hr/>
		<span>#</span>   <i>Load location definition by id</i><hr/>
		<span>*</span> <i>Save into New location definition label and auto-generated id</i><br/>
		<span>*#</span> <i>Save into New location definition id</i><br/>
		<span>^#</span> <i>Rename to New location definition id</i><hr/>
		<i>NOTE: When saving, if text is an empty string, will save all existing overwrites over current location definition id. If renaming and text is empty, will perform deletion.</i>
</p>
	  </div>
    </div>

  

</div>
</body>
</html>

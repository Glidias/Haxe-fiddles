<!DOCTYPE html>
<html>
<head>
<title>HTML Interaction</title>
<meta name="description" content="Show a GoJS Palette in a floating window and use an Inspector for changing the appearance of the selected node." />
<!-- Copyright 1998-2016 by Northwoods Software Corporation. -->
<meta charset="UTF-8">
<script src="go.js"></script>

<link rel="stylesheet" href="http://ajax.googleapis.com/ajax/libs/jqueryui/1.11.3/themes/smoothness/jquery-ui.css" />
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.11.3/jquery-ui.min.js"></script>

<!-- Spectrum color picker, pre-requisitie for the inspector -->
<link href="assets/spectrum.css" rel="stylesheet" type="text/css"/>
<script src="assets/spectrum.js"></script>

<link rel='stylesheet' href='../extensions/inspector.css' />
<script src="../extensions/inspector.js"></script>
<script src="../extensions/ExtendedBrush.js"></script>
<script src="../../dat.gui.js"></script>
<script src="../../guiGlue.js"></script>
<script src="../../vue.min.js"></script>
<script src="../../index.js"></script>

<script id="code">
(function() {

	var myDiagramDivs;
	
	function onUIDragStart() {
		myDiagramDivs.css("pointer-events", "none");
	}
	function onUIDragStop() {
		myDiagramDivs.css("pointer-events", "auto");
	}
	
	// TODO:
	
	// pin adornment
	// do not allow selection of prototypes, hide locationdefinition guis for prototypes
	
	// location definition list dropdown
	// location definition overwrites
	// location state panel
	
	
	function getCategoryStringFromType(newValue) {
	
		if (typeof(newValue) != 'number') return;
		return newValue === LocationDefinition.TYPE_POINT ? "point" : newValue=== LocationDefinition.TYPE_PATH ? "path" : "region";
	}
	function getUniformSize(size) {
		if (typeof(size) != 'number') return;
		if (size < 0) size = 999999999;
		return new go.Size(size,size);
	}
	
	function updateAllControllers(newTarget) {
		// method to update all object targets of:
	  var i =  this._controllers.length;
	  var c;
	 
	  while(--i > -1) {
		c = this._controllers[i];
		c.object = newTarget;
		c.updateDisplay();
	  }
	  
	   // and all sub-leaf proxies:
	   if (this["_subProxies"]) {
		 i = this._subProxies.length;
		  while(--i > -1) {
			this._subProxies[i]._target = newTarget;
			
		 }
	   }
	}
	
	var targetProxyHandler = {
		set: function(t, prop, value, receiver) {
			if (prop.charAt(0) != "_") {
				t._target[prop] = value;
			 
			}
			else  {
				t[prop]= value;
				if (prop === "_target" && t["_onTargetChanged"]) {
					t._onTargetChanged.apply(t, [value]);
				}
			}
		}
		,get: function(t, prop, receiver) {

			return (prop.charAt(0) != "_" ? t._target : t )[prop];
		}
	};
	


	function exposeHxMappingClassesToGlobalNamespace() {
		var p;
		var arr = [];
		for (p in textifician.mapping) {
			window[p] = textifician.mapping[p];
		}
	}
	exposeHxMappingClassesToGlobalNamespace();
	var TJSON = tjson.TJSON;

	
	var DatUtil = dat.gui.DatUtil;
	//DatUtil.DEFAULT_FLOAT_STEP = .001;
	
	var world = new TextificianWorld();
	world.setupDefaultNew();
	

	
	window.init = init;
  function init() {
  
	//DATGUI
	var specsLocationDefinition = DatUtil.setup( new LocationDefinition() );
	specsLocationDefinition.size.step = .001;
	
	var params = {};
	var gui = guiGlueRender(specsLocationDefinition, null, params);
	gui.getControllerByName("size").__input.setAttribute("step", "any");
	
	// some mods for filtering
	var liNumberRows = $(gui.domElement).find("li.number");	
	liNumberRows.find("input").each( function(index, item) {
		item = $(item);
		item.attr( "number", "");
	});
	liNumberRows.find("select").each( function(index, item) {
		item = $(item);
		item.attr( "number", "");
	});
	/*
	liNumberRows.find("option").each( function(index, item) {
		item = $(item);
		item.attr( "v-bind:value", item.val());
	});
	*/

	Vue.directive('dat-instance', {  // Binds to Dat.gui folders's domElement.firstChild => UL element
		bind: function(val) {
			var self = this;
			this._datGui = $(this.el).data("dat-gui");
			 this._datGui.onClosedChange( function(isClosed) {
				self.vm.$set( self.expression, (isClosed ? null : self._datGui._guiGlueParams ) );
			 });
		},
		update: function(val, lastVal) {
	
			this._datGui.closed = val == null;
		
			
		},
		unbind: function() {
			this._datGui.onClosedChanged(null);
		}
	});
	

	
	Vue.directive('dat-input',{  // Binds to Dat.gui controller's domElement.firstChild => Div input element
		bind: function() {
			var self = this;
			this._datController = $(this.el).data("dat-controller");
			 this._datController.onChange( function(val) {
				self.vm.$set( self.expression, val );
			 });
		},
		update: function(val) {
			if (isNaN(val)) return;
			this._datController.setValue(val);//(val);
			this._datController.updateDisplay();
		},
		unbind: function() {
			 this._datController.onChange(null);
		}
	});


	Vue.directive('dat-slider',{  // Binds to Dat.gui controller's domElement.firstChild => Div wrapper element
		bind: function() {
			var self = this;
			this._datController = $(this.el).data("dat-controller");
				this._datController.onChange( function(val) {
				self.vm.$set( self.expression, val );
			 });
		},
		update: function(val) {
			this._datController.setValue(val);
		},
		unbind: function() {
			 this._datController.onChange(null);
		}
	});
	
	Vue.directive('dat-bitmask',{  // Binds to Dat.gui folder's domElement.firstChild => UL element
		bind: function() {
			var self = this;
			//var liBoolList = $(this.el).children("li.boolean");
			var el = $(this.el);
			var folder = el.data("dat-gui");
			var controllers = folder.__controllers;
			var p;
			var c;
			var len = controllers.length;
			var initialValue = 0;
			
			var titleCheck = el.children("li.title");
			titleCheck.html( titleCheck.html() + ": ");
			var labelListCheck = titleCheck.children("span.labellist");
			if (labelListCheck.length ==0 ) {
				labelListCheck = $('<span class="labellist"></span>');
				titleCheck.append(labelListCheck);
			}
			
			
			this.labelList = labelListCheck;
			this.controllers = controllers;
			
			
			
			for (i=0; i< len; i++) {
				c = controllers[i];
				initialValue |= c.getValue() ? c._guiGlue._bit : 0;
				c.onChange(function(val) {
					if (val) {
						self.bitmaskValue |= this._guiGlue._bit;
					}
					else {
						self.bitmaskValue &= ~(this._guiGlue._bit);
					}
					
					self.vm.$set( self.expression, self.bitmaskValue );
					
					//console.log( self.expression + "=" + self.bitmaskValue);
				});
			}
			
			this.bitmaskValue = initialValue;
		//	console.log( self.expression + "=" + this.bitmaskValue);
		
		},
		update: function(val) {	
			//alert(val);
			this.bitmaskValue = val;
			
			var i;
			var c;
			var controllers= this.controllers;
			var len = controllers.length;
			var arr = [];
			var v;
			for (i=0; i< len; i++) {
				c = controllers[i];
				c.setValue( v=(val & c._guiGlue._bit)!=0 );
				if (v) arr.push('<span class="prop">'+c.property+'</span>');
			}
			
			this.labelList.html( ""+arr.join(", ") );
		},
		unbind: function() {
			var i;
			var controllers= this.controllers;
			var len = controllers.length;
			for (i=0; i< len; i++) {
				controllers[i].onChange( null );
			}
		}
	});


	var guiFolders = gui.getAllGUIs();
	var p;
	var g;
	var c;
	var f;
	var expressionPrefix = "selected.";
	var guiSubInstances = [];
	
	function resetAllGUISubInstances() {   
		var i  = guiSubInstances.length;
		while(--i > -1) {
			guiGlueApplyDefaults(guiSubInstances[i]._guiGlue, guiSubInstances[i]._guiGlueParams);
		}
	}
	
	for (p in guiFolders) {
		g= guiFolders[p];
		
		if (g._guiGlue._dotPath != undefined) {
			if (g._guiGlue._dotPath != "") {
				$(g.domElement.firstChild).data("dat-gui", g).attr("v-dat-instance", expressionPrefix+ g._guiGlue._dotPath).attr("v-node", expressionPrefix+ g._guiGlue._dotPath);
				guiSubInstances.push(g);
			}
			
		    for (c in g.__controllers) {
				var cn = g.__controllers[c];
				
				var dotPath =( g._guiGlue._dotPath!= "" ?  g._guiGlue._dotPath + "." : "")+ cn.property;
				if (cn.domElement.firstChild.nodeName.toLowerCase() != "div") {  // assumed input
					jQuery(cn.domElement.firstChild).data("dat-controller", cn);
					
					//if (jQuery(cn.domElement.firstChild).parents("li.number").length) {
					//	cn.domElement.firstChild.setAttribute("lazy", "");
					//}
					if (!jQuery(cn.domElement.firstChild).parents("li.number").length) {
						cn.domElement.firstChild.setAttribute("v-model", expressionPrefix+dotPath);
					}
					else {
						cn.domElement.firstChild.setAttribute("v-dat-input", expressionPrefix+dotPath);
					
					}
				}
				else {
					if (jQuery(cn.domElement.firstChild).parents("li.has-slider").length) {
						jQuery(cn.domElement.firstChild).data("dat-controller", cn).attr("v-dat-slider", expressionPrefix+dotPath);
					}
					else alert("TODO: NEED TO resolve controller directive for:"+cn.property);
					
				}
				cn.domElement.firstChild.setAttribute("v-node", expressionPrefix+dotPath);
			}
			
			for (f in g.__folders) {
				var folder = g.__folders[f];
				if (folder._guiGlue._dotPath == undefined) {
					var parentLI = jQuery( jQuery(folder.domElement).parents("li")[0] );
					if (parentLI.hasClass("bitmask")) {
						var dotPath =( g._guiGlue._dotPath!= "" ?  g._guiGlue._dotPath + "." : "")+ f;
						$(folder.domElement.firstChild).data("dat-gui", folder).attr("v-dat-bitmask", expressionPrefix+dotPath ).attr("v-node", expressionPrefix+dotPath);
					}
					
					
					else alert("TODO: need to resolve folder directive for:"+f );
				}
			}
		}
	}
	
	
	

	// App specific setup
	$(gui.domElement).attr("id", "locationDefGUI");
	
	var inspectPropertyChainLookup = TextificianUtil.getPropertyChainObj({}, "");
	var _inspectedNodeVal=null;
	var _inspectedGoNode = null;
	var leafBindingHash = { size:"desiredSize", label:"text", type:"category" };
	
	Vue.directive('node', function(newValue, oldValue) {
		if (_inspectedNodeVal == null) return;
		
	//	if (newValue === undefined) return;  // if value is strictly undefined, can process be skipped?
		
		var splitExp  = this.expression.split(".");
		splitExp.shift();  // remove off selected prefix in expression
		
		if (newValue != null && typeof(newValue) === "object") {
			newValue = TJSON.parse(TJSON.encode(newValue));
		}
		/*
		else {
			if (splitExp.length > 1 && splitExp[0] === "indoorLocationSpecs") {
				console.log(this.expression + " = " +newValue);
			}
			else if (newValue === undefined) {
				console.log("Setting the value as undefined: "+this.expression);
			}
		}
		*/
	
		inspectPropertyChainLookup.setupProperty( _inspectedNodeVal.def,  splitExp.join(".") );
		var result = inspectPropertyChainLookup.setPropertyChainValue(newValue);
		
		
		var leafProp = splitExp[splitExp.length - 1];
		
		if ( leafBindingHash[leafProp] ) {
			updateRelatedNodesOfModel(myDiagram.model, _inspectedNodeVal.def, leafBindingHash[leafProp]);
		}
	});
	
	
	// Vuemodel for LocationDefinition only
	var vueModel = new Vue({
		el:"#locationDefGUI",
		data: { selected: $.extend(true, {}, gui._guiGlueParams) }
	});
	

	var lastInspectedLocDef = null;
	function inspectGoNode(goNode) {

		gui.domElement.removeAttribute("hidden");
		
		var node = goNode.node;
		_inspectedGoNode = goNode;
		
		var nodeVal = node.val;
		_inspectedNodeVal = nodeVal;
		
		// consider todo: check if locDef is changed, if not changed no need to update
		var locDef = nodeVal.def;
		
		if (lastInspectedLocDef != locDef) {
			// reset temporary view-cache UI state values when location definition inspection-target changes
			resetAllGUISubInstances(); 
		}
		lastInspectedLocDef = locDef;
		// lazy JSON approach to convert a Model to vueModel
		var jsonStr = TJSON.encode(locDef);
		var newVueModelData = TJSON.parse(jsonStr);
		//console.log("Inspecting", locDef);
	
		// setup new location def
		vueModel.selected = newVueModelData;
		
		// nodeVal.state
	}

	gui.domElement.addEventListener('dragstart', onUIDragStart);
	gui.domElement.addEventListener('dragstop', onUIDragStop);
  
	// GOJS
    if (window.goSamples) goSamples();  // init for these samples -- you don't need to call this

    // Note that we do not use $ here as an alias for go.GraphObject.make because we are using $ for jQuery
    var GO = go.GraphObject.make;  // for conciseness in defining templates

    myDiagram =
      GO(go.Diagram, "myDiagramDiv",  // must name or refer to the DIV HTML element
         { allowDrop: true,
			
		 	"undoManager.isEnabled": true,
                    "toolManager.hoverDelay": 100  // how quickly tooltips are shown
		 
		 }
		 
		);  // must be true to accept drops from the Palette
	myDiagram.mouseDrop = function(e, node) {

		  var it = myDiagram.toolManager.draggingTool.copiedParts;
		  if (it == null) {
			return;
		  }
		  it = it.iterator;
		  while (it.next()) {
				if (it.key instanceof go.Node) { 
					scaleNode(it.key, myDiagram.scale);
				}
				else if (it.key instanceof go.Link) {
					scaleLink(it.key, myDiagram.scale);
				}
		  }
		  

	}
	
	//myDiagram.linkTemplate.curve = go.Link.Bezier;
	myDiagram.linkTemplate.curviness = 1;
	//myDiagram.linkTemplate.bind(new go.Binding("curviness", "curviness"));

	myDiagram.addLayerBefore(GO(go.Layer, {name:"Regions"}), myDiagram.findLayer(""));
	myDiagram.addLayerAfter(GO(go.Layer, {name:"Points"}), myDiagram.findLayer(""));
	
    // define several shared Brushes
    var fill1 = "rgb(243,134,48)"
    var brush1 = "rgb(203,84,08)";

    var fill2 = "rgba(167,219,216, .65)"
    var brush2 = "rgb(127,179,176)";

    var fill3 = "rgba(224,228,204, .5)"
    var brush3 = "rgb(184,188,164)";
	
	//  var fill1 = "rgb(243,210,231)"
//   var brush1 = "rgb(65,180,181)";
 //  var fill2 = "rgba(167,219,216, .85)"
 //   var brush2 = "rgb(127,179,176)";


   // var fill4 = "rgb(243,134,48)"
 //   var brush4 = "rgb(203,84,08)";
	
	var TEXTLABEL_BASEWIDTH = 80;
	var MAX_SHAPE_SIZE = 512;
	var POINT_SIZE = 5;
	
	function getNodeTemplate(figure, fill, stroke, maxSize, layout, layerName) {
	
		var panelLayout = layout ? layout :  go.Panel.Vertical;
		if (!layerName) layerName = "";
		
		var textBlockParams = [go.TextBlock,
			{ 
			maxSize: new go.Size(TEXTLABEL_BASEWIDTH, NaN),
			wrap: go.TextBlock.WrapFit,
			textAlign: "center",
			editable: false,
			pickable: false,
			portId:"",
			font: "bold 7pt Arial, sans-serif",
			name: "TEXT" , portId:""
			},
			new go.Binding("text", "text" ).makeTwoWay()
		
		];
		
		textBlockParams.push(
				   new go.Binding("pickable", "", function(data) {
			
						return myDiagram.scale < 1;
				  })
		  );
			
		///*
		//if (panelLayout === go.Panel.Spot) {
			textBlockParams.push(
				   new go.Binding("fromLinkable", "", function(data) {
						return myDiagram.model.modelData.linkable;
				  }),
					new go.Binding("toLinkable", "", function(data) {
						return myDiagram.model.modelData.linkable;
				  })
		  );
		//}
		//*/
		var textBlock  =  GO.apply(null, textBlockParams);

		
				
		var shape = GO(go.Shape, "Ellipse",
			  { strokeWidth: 2, fill: fill1, name: "SHAPE"
			 , desiredSize: new go.Size(16, 16)
			 ,minSize:  new go.Size(1,1)
				,maxSize:  new go.Size(maxSize ? maxSize : NaN, maxSize  ? maxSize : NaN)
				,figure:figure
				,fill:fill
				,stroke:stroke
				,portId: "", cursor: "pointer",  // the Shape is the port, not the whole Node
				// allow all kinds of links from and to this port
			  fromLinkableSelfNode: false, fromLinkableDuplicates: false,
			   toLinkableSelfNode: false, toLinkableDuplicates: false
			   
			  },
			  
			 // new go.Binding("figure", "figure"),
			  
			 //new go.Binding("fill", "fill"),
			 // new go.Binding("stroke", "stroke"),
			   
			 new go.Binding("desiredSize", "", function(v) { return v.node ? getUniformSize(v.node.val.def.size) : v.size; } )
			  ,
				   new go.Binding("fromLinkable", "", function(data) {
						return myDiagram.model.modelData.linkable;
				  }),
					new go.Binding("toLinkable", "", function(data) {
						return myDiagram.model.modelData.linkable;
				  })
			  
			  );
			 
		var goParams = [go.Node, panelLayout,
        { locationSpot: go.Spot.Center },
        new go.Binding("location", "loc").makeTwoWay(), new go.Binding("category", "", function(v) { return v.node ? getCategoryStringFromType(v.node.val.def.type) : v.category; }  ) ];
			
		if (panelLayout == go.Panel.Spot)  {
			goParams.push(shape, textBlock);
		}
		else {
			goParams.push(textBlock, shape);
		}
		
		goParams.push({layerName:layerName});
		
		
		return GO.apply(null, goParams);
	}



	 myDiagram.nodeTemplateMap.add("point", getNodeTemplate("Square",fill1,brush1, POINT_SIZE, null, "Points"));
	  myDiagram.nodeTemplateMap.add("path", getNodeTemplate("Diamond",fill2,brush2, MAX_SHAPE_SIZE, null, ""));
	  myDiagram.nodeTemplateMap.add("region",getNodeTemplate("Circle",fill3,brush3, MAX_SHAPE_SIZE, go.Panel.Spot, "Regions"));

	  function scaleLink(link, newscale) {
		link.curviness = 1 * origscale/newscale;
	  }
	  function scaleNode(node, newscale) {
	  	//origscale / newscale;
			
			var text = node.findObject("TEXT");
			text.scale =  origscale / newscale;//newscale < .5 ? origscale / newscale*.5 : 1;
			text.visible = newscale >= .1 ? true : false; 
			text.maxSize.width = TEXTLABEL_BASEWIDTH * origscale / newscale;
			if (node.category === "point") {
				var shape = node.findObject("SHAPE");
				shape.scale =  newscale >= .3 ? 1 :  origscale / newscale * .3;
			}
			else if (node.category === "path") {
				var shape = node.findObject("SHAPE");
				var curSize = shape.desiredSize.width >= MAX_SHAPE_SIZE ? MAX_SHAPE_SIZE : shape.desiredSize.width;
				curSize *=newscale;
				shape.scale =  curSize >= 3 ? 1 : 3/curSize;
			}
	  }
	  
	  // This code keeps all nodes at a constant size in the viewport,
      // by adjusting for any scaling done by zooming in or out.
      // This code ignores simple Parts;
      // Links will automatically be rerouted as Nodes change size.
      var origscale = NaN;
      var oldscale = NaN;
      myDiagram.addDiagramListener("InitialLayoutCompleted", function(e) { origscale = oldscale = myDiagram.scale; });
      myDiagram.addDiagramListener("ViewportBoundsChanged", function(e) {
        if (isNaN(origscale)) return;
        var newscale = myDiagram.scale;
        if (oldscale === newscale) return;  // optimization: don't scale Nodes when just scrolling/panning
        oldscale = newscale; 
        myDiagram.skipsUndoManager = true;
        myDiagram.startTransaction("scale Nodes");
		
		//myDiagram.linkTemplate = myDiagram.linkTemplate;
		
        myDiagram.nodes.each(function(node) {  // consider todo: only perform for nodes within visibility set? need to form visibilty set per scroll though.
		
			scaleNode(node, newscale);
			
          });
		  
		   myDiagram.links.each(function(link) {  // consider todo: only perform for nodes within visibility set? need to form visibilty set per scroll though.
		
			scaleLink(link, newscale);
			
          });
		  
		  
		 // myDiagram.model.updateTargetBindings("
        myDiagram.commitTransaction("scale Nodes");
        myDiagram.skipsUndoManager = false;
		
      });
	  
	  
	
	function writePropertiesOver(obj, src) {
		var p;
		if (src == null) return obj;
		for(p in src) {
		
			obj[p] = src[p];
		}
		return obj;
	}
		  
	var textProxy = {
	   get : function() {
			return this.node.val.defOverwrites != null && this.node.val.defOverwrites.label  ? this.node.val.defOverwrites.label : this.node.val.def.label;
	   },
	   set : function(val) {
			var prefix = val.charAt(0);
			if (prefix=== "#") {	// lookup location definition
				val = val.slice(1);
				var tryDef = world.getLocationDef( val );
				if (tryDef != null) {
					this.node.val.def = tryDef;
					this.node.val.defOverwrites = null;
					this.isProto =  val =="Point" || val ==="Path" || val === "Region";
					inspectGoNode(this);
				}
				else {
					alert("Failed to find location definition: "+val);
				}
			}
			else if (prefix === "~") {  // write label directly into location definition
				if (this.isProto || val =="Point" || val ==="Path" || val === "Region") {
					alert("Sorry, cannot write label directly into prototype location definition id! Save it first with * prefix!");
					return;
				}
				val = val.slice(1);
				if (this.node.val.defOverwrites != null) {
					delete this.node.val.defOverwrites["label"];
				}
				this.node.val.def.label = val;
			}
			else if (prefix === "*") { // save location definition
				val = val.slice(1);
				//
				var dupLoc;
				
				if (val.charAt(0) === "#") {
					val = val.slice(1);
					if (val === "") {
						if (this.isProto || this.node.val.def.id =="Point" || this.node.val.def.id ==="Path" || this.node.val.def.id === "Region") {
							alert("Sorry, cannot write directly into prototype location definition! Save it first with * prefix!");
							return;
						}
						else writePropertiesOver(this.node.val.def , this.node.val.defOverwrites);
						this.node.val.defOverwrites = null;
						return;
					}
					dupLoc = writePropertiesOver( world.getDuplicationLocationDef(this.node.val.def, val) , this.node.val.defOverwrites);
				}
				else {
					if (val === "") {
						if (this.isProto || this.node.val.def.id =="Point" || this.node.val.def.id ==="Path" || this.node.val.def.id === "Region") {
							alert("Sorry, cannot write directly into prototype location definition! Save it first with * prefix!");
							return;
						}
						else writePropertiesOver(this.node.val.def , this.node.val.defOverwrites);
						this.node.val.defOverwrites = null;
						return;
					}
					if (this.node.val.defOverwrites == null) this.node.val.defOverwrites = {};
					this.node.val.defOverwrites.label = val;
					dupLoc = writePropertiesOver( world.getDuplicationLocationDef(this.node.val.def, val) , this.node.val.defOverwrites);
				}
			
				try {
					world.addLocationDef(dupLoc);
					this.node.val.defOverwrites = null;
					this.node.val.def = dupLoc;
					this.isProto = false;
					inspectGoNode(this);
				}
				catch(err) {
					alert(err);
				}
				
			}
			else {  // write label overwrite
				if (val =="Point" || val ==="Path" || val === "Region") {
					alert("Sorry, prototype id value reserved");
					return;
				}
				if (val === "") {
					if (this.node.val.defOverwrites != null) {
						delete this.node.val.defOverwrites["label"];
						
						
					}
					val = this.node.val.def.label;
					this.isProto =  val =="Point" || val ==="Path" || val === "Region";
					return;
				}
				if (this.node.val.defOverwrites == null) {
					this.node.val.defOverwrites = { label: val };
				}
				else this.node.val.defOverwrites.label = val;
				//this.node.val.def.label = val;
			
			}
	   }
	};
	
	
					
	function updateRelatedNodesOfModel(model, def, prop) {
		var nodeDataArr = model.nodeDataArray;
		var i = nodeDataArr.length;
		var o;
		while(--i > -1) {
			o = nodeDataArr[i];
			if (o.node && o.node.val.def === def) model.updateTargetBindings(nodeDataArr[i], prop);
		}
	}
	
	
	
	
  myDiagram.model.linkKeyProperty = "key";
  myDiagram.model.addChangedListener(function(e) {
    if (e.isTransactionFinished) {
      var tx = e.object;
	  
      if (tx instanceof go.Transaction && console && e.model) {
       // console.log(tx.toString());
		
		if (true || tx.name != "Move") {
		
			var methodToCalls = [];
			var nodesToAdd = [];
			tx.changes.each(function(c) {
			
			  if (c.model) {
				if ( c.model === c.object ) { // deemed insertion or removal
					if (c.newValue != null && c.oldValue == null) {  // insertion infered
					
						if (c.propertyName == "nodeDataArray") {  // insert node
							nodesToAdd.push( c.newValue );
						}
						else if (c.propertyName == "linkDataArray") {  // create link
							
						}
					}
					else if (c.newValue == null && c.oldValue != null) { // removal infered
						if (c.propertyName == "nodeDataArray") {  // remove node
							//alert("REMOVE NODE");
							
						}
						else if (c.propertyName == "linkDataArray") {  // remove link
							//alert("REMOVE LINK");
						}
					}
					else {
						console.log	("Could not resolve this transaction case: "+tx);
					}
				}
				else {  // deemed modifying of data within model
					if (c.propertyName === "loc") {   // moving 
						var n = c.object.node;
						if (n != null) {
							n.val.x = c.newValue.x;
							n.val.y = c.newValue.y;
						}
					}
					else if (c.propertyName === "linkable") {
						// irreleavant. do nothing
					}
					else if (c.propertyName === "text") {
						methodToCalls.push(updateRelatedNodesOfModel, [e.model, c.object.node.val.def, "text"]);
						methodToCalls.push(updateRelatedNodesOfModel, [myPalette.model, c.object.node.val.def, "text"]);
					}
					else if (c.propertyName === "size") {

					}
					else if (c.propertyName === "node") {
						// irrelavant
					}
					else if (c.propertyName === "category") {
						// irrelavant
					}
					else { //
					  alert("could not resolve:"+c.propertyName);
					}
				}

				console.log( c.object," " +c.modelChange + ","+c.propertyName+","+c.oldParam +", "+c.newParam );
				//console.log("OldValue:", c.oldValue);
				//console.log("NewValue:", c.newValue);
				
				//console.log( model.toIncrementalJson(e) );
			  }
			});
			
			var i;
			for(i=0; i< methodToCalls.length; i+=2) {
				methodToCalls[i].apply(null, methodToCalls[i+1]);
			
			}
			
			// creation of nodes
				i = 0;
					var v;
				var o;
				for (i=0; i<nodesToAdd.length; i++) {
					o =nodesToAdd[i];
					if (o.node != null) {  // DUPLICATE NODE CASE
						//alert(flagDownKeys );
						e.model.setDataProperty(o,"node",v= world.addLocationNode(world.getLocationDef(o.node.val.def.id), o.loc.x, o.loc.y, 0, null, ( false ? o.node.val.cloneOverwrites() : o.node.val.defOverwrites) ));
					}
					else {  // NEW NODE CASE
						
						e.model.setDataProperty(o,"node",v= world.addLocationNode(world.getLocationDef(o.locid).setSize(o.size.width), o.loc.x, o.loc.y, 0, null, null ));
						inspectGoNode(o);
					}
					
					if (o.text != textProxy) {
						Object.defineProperty(o,"text",textProxy);
						e.model.updateTargetBindings(o, "text");
					}
			

				}
	
		  }
		//  /*
		  else  {   // DEPRECIATED atm due to recursion problem with toIncrementalJSON
			//	/*
				console.log( e.model.toIncrementalJson(e) );
				var moveJson = e.model.toIncrementalJson(e);
				moveJson = JSON.parse(moveJson);
				var modData = moveJson.modifiedNodeData;
				
				var i =modData ?  modData.length : 0;
				var o;
				while(--i > -1) { // readonly
					o = modData[i];
					//= o.loc.x;
					//= o.loc.y;
					
				}
				//*/
	
				
				
		  }
		//  */
	  }
	  
    }
  });
		  
	function classify(instance) {
		instance["class"] = "awawaawtwaaw";
		return instance;
	}


    // initialize the Palette that is in a floating, draggable HTML container
    myPalette = new go.Palette("myPaletteDiv");  // must name or refer to the DIV HTML element
	myPalette.allowZoom = false;
	
//	palTemplate.findObject("SHAPE").maxSize = new go.Size(20,20);
	myPalette.nodeTemplateMap.add("point", getNodeTemplate("Square",fill1,brush1,20));
	 myPalette.nodeTemplateMap.add("path", getNodeTemplate("Diamond",fill2,brush2,20));
	 myPalette.nodeTemplateMap.add("region",getNodeTemplate("Circle",fill3,brush3,20));
	  
  	
	  
    myPalette.model = new go.GraphLinksModel([
      { locid:"Point", isProto:true, text:"Point", category:"point",  size:new go.Size(POINT_SIZE,POINT_SIZE)   },
      { locid:"Path", isProto:true, text:"Path",  category:"path",  size:new go.Size(12,12) },
      { locid:"Region", isProto:true,  text:"Region",  category:"region", size:new go.Size(30,30) }
    ]);
	
	var FLAG_SHIFT_DOWN = 1;
	var flagDownKeys = 0;
	
	jQuery(window).keydown( function(e) {
		if (e.keyCode === 16) {	 // shift
			flagDownKeys |= FLAG_SHIFT_DOWN;
			myDiagram.model.setDataProperty(myDiagram.model.modelData, "linkable", true);
			
		}
		//console.log(flagDownKeys);
	});
	jQuery(window).keyup( function(e) {
		if (e.keyCode === 16) {  // shift
			flagDownKeys &= ~FLAG_SHIFT_DOWN;
			myDiagram.model.setDataProperty(myDiagram.model.modelData, "linkable", false);
		}
	//	console.log(flagDownKeys);
		
		 
	});

    myPalette.addDiagramListener("InitialLayoutCompleted", function(diagramEvent) {
      var pdrag = document.getElementById("paletteDraggable");
      var palette = diagramEvent.diagram;
      var paddingHorizontal = palette.padding.left + palette.padding.right;
      var paddingVertical = palette.padding.top + palette.padding.bottom;
	  pdrag.style.top = 8  + "px";
	  pdrag.style.left = 270  + "px";
      pdrag.style.width = palette.documentBounds.width + 20  + "px";
      pdrag.style.height = palette.documentBounds.height + 30 + "px";
    });
	
	$("#infoDraggable").focus( function() {
		
	});
	
	myDiagramDivs = $("#myDiagramDiv").add($("#myPaletteDiv"));
	
	
	myDiagram.addDiagramListener("ChangedSelection", function(e) {
		var selection = myDiagram.selection.first();
		  if (selection === null || !(selection instanceof go.GraphObject) || !selection.data || !selection.data.node ) {  // hide UIs
			gui.domElement.setAttribute("hidden", true);
		  return;
		}
		
		inspectGoNode(selection.data);

	
	});
	
	


    $(function() {
        $("#paletteDraggable").draggable({handle: "#paletteDraggableHandle", start:onUIDragStart, stop:onUIDragStop}).resizable({
          // After resizing, perform another layout to fit everything in the palette's viewport
		  start: onUIDragStart,
          stop: function(){ myPalette.layoutDiagram(true); onUIDragStop(); }
        });

        var inspector = new Inspector('infoDraggable', myDiagram,
          {
            
		  acceptButton: true,
            resetButton: true
          // /*
			, propertyNames: {
		//		"Node": ["category"],
              //"Node": ["location", "background", "scale", "angle", "isShadowed", "resizable"],
              //"#SHAPE": ["fill", "stroke", "strokeWidth", "figure"],
              "#TEXT": ["text"]
            }
			//*/
          });
		  
        });

  }
  
})();
</script>



<style type="text/css">
.draggable {
  display: inline-block;
  vertical-align: top;
  border: 4px solid #BBB;
  border-radius: 4px;
  background-color: #F5F5F5;

  position: absolute;
  top: 20px;
  left: 120px;
  z-index: 500;
}

.dg textarea {
	font-size:12px;
}
.dg input[type=text] {
	font-size:12px;
}

li.folder.bitmask ul {
	background-color:black;
}
li.folder.bitmask ul li.boolean {
	display:inline-block;
}
li.folder.bitmask ul li .property-name {
	width:auto;
}
li.folder.bitmask ul li.boolean .c {
	width:auto;
}

li.folder.bitmask ul li.title {
	whitespace:nowrap; 
}
li.folder.bitmask ul li.title .labellist {
 word-spacing: -2px;

 }
li.folder.bitmask ul li.title .labellist .prop {
	font-size:9px;
	color:magenta;
	margin:0 0px;
	

}

li.folder.instance .title {
	background-image:none;
	padding-left:8px;
}

li.folder.instance .title:before {
	margin-right:8px;
	content:'\2611';
}

li.folder.instance .closed .title:before {
	content:'\2610';
}


.handle {
  background-color: lightblue;
  cursor: move;
  text-align: center;
  font: bold 12px sans-serif;
}

#infoDraggable {
  font: 12px helvetica, sans-serif;
  background-color:rgba(45,45,45,.8);
}	

#infoDraggable .inspector {
	background-color:#000000;
	
	display:block;
}

#myInfo {
  padding: 6px;
}

#myPaletteDiv {
  background-color: #F5F5F5;
  width: 100%;
  height: 100%;
}

/*
One simple way of making a div fill its space,
with allowances for the title (top) and the resize handle (bottom)
*/
#paletteContainer {
  position:absolute;
  bottom: 14px;
  left: 0px;
  right: 0px;
  top: 14px;
}
#locationDefGUI > ul:before {
	content: 'location definition';
	display:block;
	padding-left:10px;
	background-color:#666666;	
}

#infoDraggableInstruct  {
	
}
#infoDraggableInstruct span {
	font-style:normal;	
	font-weight:bold;
	color:yellow;
}
#infoDraggableInstruct i {
	font-size:11px;
	font-weight:normal;
}
 canvas:focus{outline:none;}
 
 .dg input[readonly=readonly] {
	color:yellow !important;
}

</style>
</head>
<body onload="init()" style="margin:0;padding:0">
<div id="sample">

    <div id="paletteDraggable" class="draggable" style="height: 300px;	">
      <div id="paletteDraggableHandle" class="handle">Palette</div>
      <div id="paletteContainer">
        <div id="myPaletteDiv"></div>
      </div>
    </div>

    <div style="display: block; z-index:0;vertical-align: top;  padding:0;margin:0;width:100%; height:100%;position:absolute; top;0; left:0;">
      <div id="myDiagramDiv" style="outline:none;background-color:whitesmoke;  margin:0 auto;	  width:100%; height: 100%"></div>
    </div>

    <div id="infoDraggable" style="position:relative; display: inline-block; vertical-align: top; padding: 5px; z-index:1">
      <div id="myInfo" style="visibility:visible; margin-bottom:10px;"><h1>Textifician Mapper</h1>Selecting nodes in the Main Canvas will show linked location definition here</div>
	  <div id="infoDraggableInstruct" style="position:absolute;bottom:0;left:0;padding:5px;">
		 <h4>TEXT <span>prefix</span> legend:</h4>
		 <p>
		<span>(no prefix)</span> <i>Create overwrite label</i> <hr/>
		<span>~</span>  <i>Write label into existing location definition</i><hr/>
		<span>#</span>   <i>Load location definition by id</i><hr/>
		<span>*</span> <i>Save into New location definition (auto-generate id)</i><hr/>
		<span>*#</span> <i>Save into New location definition (with id) </i><hr/>
		<i>NOTE: When saving, if text is an empty string, will save all existing overwrites over current location definition id.</i>
</p>
	  </div>
    </div>

  

</div>
</body>
</html>
